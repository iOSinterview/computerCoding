



[TOC]





# 基础篇

## MySQL的基础架构

（一条select语句执行的流程）

总体架构图：

![MySQL基础架构](https://s2.loli.net/2024/08/16/uWQtjdp5JeBFvkl.png)

MySQL的架构主要分为两层：Server层和存储引擎层

- **Server层负责建立连接、分析和执行SQL。**主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。
- **存储引擎层负责数据的存储和提取**。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。

**第一步：连接器**

连接器负责跟客户端建立连接、获取权限、维持和管理连接。当身份认证完成以后，如果没有后序操作，连接会进入空闲状态，但`wait_timeout`过期时，连接器会关闭该连接。

连接MySQL服务通过以下命令：

```shell
# -h 指定 MySQL 服务得 IP 地址，如果是连接本地的 MySQL服务，可以不用这个参数；
# -u 指定用户名，管理员角色名为 root；
# -p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码
mysql -h $ip -u$user -p
```

MySQL基于TCP建立连接，因此需要经过TCP三次握手。

MySQL中的来凝结跟HTTP一样，有长短连接，一般是使用长连接，但是长连接过多是会导致内存占用更大，被系统强行杀掉（OOD），即MySQL异常重启。

```c
// 短连接
连接 mysql 服务（TCP 三次握手）
执行sql
断开 mysql 服务（TCP 四次挥手）

// 长连接
连接 mysql 服务（TCP 三次握手）
执行sql
执行sql
....
断开 mysql 服务（TCP 四次挥手）
```

怎么解决这个问题呢？你可以考虑以下两种方案。

1. **定期断开长连接。**使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。
2. **客户端主动重置连接。**可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

总结：

- 与客户端进行 TCP 三次握手建立连接；
- 校验客户端的用户名和密码，如果用户名或密码不对，则会报错；
- 如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；

**第二步：查询缓存**

如果要执行的SQL语句是`select`查询语句，MySQL会先去查询缓存。**但其实查询缓存的命中率非常低，因为对于更新比较频繁的表，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了。**除非业务需要的就是一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。

**需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。**

**第三步：解析器**

在正式执行SQL语句查询前，MySQL中的解析器会先对SQL语句做解析，了解客户端输入的是什么需求，即连接需求。主要会做两件事。

- 解析器先会做`词法分析`。需要识别出里面的字符串分别是什么、代表什么，也就是识别关键字。
- 接着做`语法分析`。根据`词法分析`的结果，`语法分析`会根据语法规则，判断当前的SQL语句是否合法，然后构建语法树，方便后续模块读取表名、字段、语句类型。

**第四步：执行SQL**

接着就要进入执行 SQL 查询语句的流程了，每条`SELECT` 查询语句流程主要可以分为下面这三个阶段：

- prepare 阶段，也就是预处理阶段；
- optimize 阶段，也就是优化阶段；
- execute 阶段，也就是执行阶段；

**预处理阶段**

- 检查 SQL 查询语句中的表或者字段是否存在；
- 将 `select *` 中的 `*` 符号，扩展为表上的所有列；

**优化器**

**优化器主要负责将 SQL 查询语句的执行方案确定下来**，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。

**执行器**

根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；

**总结**

- 连接器：建立、管理连接、校验用户身份；
- 查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；
- 解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；
- 执行 SQL：执行 SQL 共有三个阶段：
  - 预处理阶段：检查表或字段是否存在；将 `select *` 中的 `*` 符号扩展为表上的所有列。
  - 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；
  - 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；

![MySQL基础架构](https://s2.loli.net/2024/08/16/nlGyPqhBbJmT4Xd.png)

## 表空间文件的结构

表空间由段（segment）、区（extent）、页（Page）、行（row）组成，InnoDB存储引擎的逻辑存储结构如下：

![](https://s2.loli.net/2024/08/22/g93cOb1wXmN4LDy.webp)

- 行：数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。
- 页：页是 InnoDB 存储引擎磁盘管理的最小单元，**InnoDB 的数据是按「页」为单位来读写的，默认每个页的大小为 16KB**，常见的有数据页、undo 日志页、溢出页等等。
- 区：在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，二十按照区为单位分配。每个区的大小为 1MB ，对于16KB的页来说，连续的64个页会被划分为一个区，这样就使得链表中相邻页的物理位置页相邻，就能使用顺序I/O。
- 段：表空间由多个段组成，段一般分为数据段、索引段、回滚段。
  1. 数据段：存放B+树中叶子节点的区的集合
  2. 索引段：存放B+树中非叶子节点的区的集合
  3. 回滚段：存放的是回滚数据的区的集合。（MVCC使用回滚实现多版本查询数据）


# 索引篇

## 索引常见面试题

## 什么是索引？有什么作用优势？

在数据库中，索引是一种数据结构，用于提高数据库表中数据的检索速度和查询效率。索引类似于书籍的目录，可以帮助数据库的存储引擎快速定位到包含特定值的行，而不必扫描整个表。

所谓的存储引擎，就是如何存储数据、如何为存储的数据建立索引以及如何更新、查询数据等技术的一个实现方法。MySQL中的存储引擎由MyISAM、InnoDB、Memory。

那么**采用索引主要可以加快数据检索速度、提高查询效率、还可以对表中的某一列进行唯一性约束。**

## 索引的分类？

- 按【数据结构】分类：**B+树索引**、Hash索引、Full-text索引
- 按【物理存储】分类：**聚簇索引（主键索引）**、二级索引（辅助索引）
- 按【字段特性】分类：主键索引、唯一索引、普通索引、前缀索引
- 按【字段个数】分类：单列索引、联合索引

### 数据结构分类

![img](https://s2.loli.net/2024/08/23/RtzvwLAQ7i9O4X6.png)

（上面这个图稍微有印象即可）

在创建表时，InnoDB存储引擎会根据不同的场景选择不同的列作为索引：

- 如果有主键，默认会使用主键作为聚簇索引的索引键(k©y)
- 如果没有主键，就选择第一个不包含NULL值的唯一列作为聚簇索引的索引键(k©y);
- 在上面两个都没有的情况下，InnoDB将自动生成一个隐式自增id列作为聚簇索引的索引键

​       其它索引都属于辅助索引(Secondary Index)，也被称为二级索引或非聚簇索引。创建的主键索引利二级索引默认使用的是B+Tree索引。

### 物理存储分类

从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引），区别如下：

- 主键索引的B+Tree的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的B+Tree的叶子节点里；
- 二级索引的B+Tee的叶子节点存放的是主键值，而不是实际数据。

所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是覆盖索引（只需要差一次B+Tree）。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是回表（查两次B+Tree）。

![回表](https://s2.loli.net/2024/08/23/moqPGOCB7jKn4N5.png)

### 字段特性分类

从字段特性的角度来看的话，分为主键索引、唯一索引、普通索引、前缀索引。

- 主键索引（primary key）：建立在主键字段上的索引，通常在创建表的时候创建，一张表最多只能有一个，且索引列的值不能为NULL。
- 唯一索引（unique key）：一张表可以有多个唯一索引，索引列的值必须唯一，可以为NULL.
- 普通索引（key）：普通字段上索引。
- 前缀索引（）：前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为char、varchar、binary、varbinary的列上。使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。`INDEX(column_name(length))，length为前缀长度`

### 字段个数分类

可以分为单列索引、联合索引。

- 单列索引：建立在单列上的索引。
- 联合索引：建立在多列上，将多个字段组合成一个索引。

使用联合索引时，存在【最左匹配原则】，比如联合索引（a,b），由于索引的前提是key有序，其中a是有序的，b是无序的，如果直接查询`where b = 2`，此时没办法使用来拟合索引。

![img](https://s2.loli.net/2024/08/23/hEFrgz9wdnb814J.png)

联合索弱引的最左匹配原则，在遇到范围查询（如`>、<`）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索弱引，但是在范围查询字段的后面的字段无法用到联合索弱引。注意，对于`>=、<=、BETWEEN、LIKE` 前缀匹配的范围查询，并不会停止匹配。

## 索引优缺点？什么时候需要/不需要索引？

### 索引的缺点

索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：

- 需要占用物理空间，数量越大，占用空间越大；
- 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大，
- 会降低表的增删改的效率，因为每次增删改索引，B+树为了维护索引有序性，都需要进行动态维护。

所以，索引不是万能钥匙，它也是根据场景来使用的。

### 什么时候适用索引？

- 字段有唯一性限制的，比如商品编码；
- 经常用于`WHERE查询条件`的字段，建立索引能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。
- 经常用于`GROUP BY`和`ORDER BY`的字段，这样在查询的时候就不需要再去做一次排序了，因为建立索引之后在**B+Tree**中的记录都是排序好的。

### 什么时候不需要创健索引？

- WHERE条件，GROUP BY，ORDER BY里用不到的字段。索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。
- 字段中存在大量重复数据，不需要创建索引。比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为MySQL还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。
- 表数据太少的时候，不需要创建索引；
- 经常更新的字段不用创建索引。比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护B+Tre的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。

## 有什么优化索引的方法？

- 前缀索引优化；
- 覆盖索引优化；
- 主键索引最好是自增的；
- 防止索引失效；

### 前缀索引优化

前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引，

使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段（比如email邮箱）作为索引时，使用前缀索引可以帮助我们减小索引项的大小。

不过，前缀索引有一定的局限性，例如：

- order by就无法使用前缀索引，因为order by需要的是整个字段的排序顺序。
- 无法把前缀索引用作覆盖索引。因为覆盖索引是指查询所需的所有数据都在索引中，可以完全通过索引来获取结果，而无需访问表数据。前缀索引因为只索引了字段的前部分，因此无法作为覆盖索引来使用。

### 覆盖索引优化

覆盖索引就是从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表。

假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？
我们可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。

所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少
了大量的/O操作。

### 主键索引最好自增

因为InnoDB创建主键索引默认使用聚簇索引，数据都会被存放在B+Tree的叶子节点上，也就是说，同一个叶子节点内的各个数据都是按主键顺序存放的。

**如果我们使用自增主键，那么每次插入一条新纪录，都是追加操作，不需要重新移动数据，这种插入数据的方法非常高效。**

如果非自增主键，每次插入主键的索引是随机的，可能会插入到某个数据页的中间位置，需要移动其他的数据来满足新数据的插入，页空间不够会造成【页分裂】，可能会造成大量内存碎片，导致索引结构不紧凑，影响查询效率。

**另外，主键字段的长度不要太大，因为主键字段长度越小，意味着二级索引的叶子节点越小（二级索3引的叶子节点存放的数据是主键值），这样二级索3引占用的空间也就越小。**

### 索引最好设置为  `NOT NULL`

有以下两个原因：

- 索引列存在`NULL`就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为`NULL`的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count会省略值为`NULL`的行。
- `NULL` 值虽然是一个没意义的值，但是它也会占用物理空间（InnoDB行格式中至少会使用一个字节存储`NULL`值列表）。

### 防止索引失效

用上了索引并不意味着查询的时候会使用索引，因此我们要避免索引失效。

## 什么时候索引会失效？

- 当我们使用左或者左右模糊匹配的时候，也就是like %xx 或者like%xx%这两种方式都会造成索引失效；
- 当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；
- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
- 在WHERE子句中，如果在OR前的条件列是索引列，而在OR后的条件列不是索引列，那么索引会失效。
- 为了更好的使用索引，索引列要设置为`NOT NULL`约束。

## 为什么MySQL采用B+Tree作为索引？

首先什么样的数据结构适合硬座索引呢？至少要满足以下需求：

1. **要尽可能少的磁盘I/O操作完成查询操作。**
2. **既能高效地查询某一个记录，也能高效地执行范围查找。**因此索引的数据最好有序，这样可以使用**【二分查找】**高效定位数据。

首先想到是【有序数组】，但是有序数组在进行插入数据的时候效率非常低。

于是我们想到了**【二叉查找树】**，**它的特点是左子树小于根节点，右子树大于根节点**，但是如果每次都是插入最大/小的元素，那么就会像一个链表，查询效率（I/O操作）从`O(logn)`升至`O(n)`。于是出现了**【平衡二叉查找树（AVL）】**，其实就是加了一个约束：**每个节点的左子树和右子树的高度差不能超过1。**查询侠侣维持在`O(logn)`。但是二叉树每个节点最多只有两个孩子，当数据非常多的时候，树会非常高，查询效率会下降。

为了降低树的高度，因此想到了**【多叉平衡查找树】**，首先是 **【B Tree】。**

**B树的特点：**

- 每个节点最多有M个子树，所有非叶节点至少有$\frac{M}{2}$颗子树，每层允许M-1个关键字。
- 每个节点包含了（索引+记录），所有叶子节点在同一层。

虽然B树降低了树的高度，提高了查询效率，但是它的每个节点都包含了索引+记录，如果当我们查询的【记录A】层数较深，那么查询过程中【非A记录节点】里的记录也会从磁盘加载到内存，而我们知识需要索引，这样不仅增加了 I/O 操作次数，也会占用内存。并且B树如果要进行范围查询，需要中序遍历，设计多个节点的磁盘 I/O 问题，效率比较低。

于是对B树进行了升级，得到了 【B+Tree】，特点如下：

- 叶子节点才会存放实际数据（索引+记录），非叶子节点只会存放索引，节约内存。
- 所有索引都会在叶子节点出现，叶子节点之间构成一个双向有序俩表，方便范围查询。
- 非叶子节点的索引也会存在于子节点中，并在子节点中有序（最大/最小索引）。

![图片](https://s2.loli.net/2024/08/23/JYLgu3a1UVkIoxt.png)

## 小结

![img](https://s2.loli.net/2024/08/23/J1RPsCAUOow4mD9.png)

# 事务篇

## 什么是事务？事务有哪些特性？

在数据库中，**事务（Transaction）** 是一组被看作一个单一逻辑的操作。这些操作要么全部成功执行，要么全部失败回滚。事务确保数据库的一致性和完整性，即使在系统故障或并发访问的情况下。

**事务的特性（ACID）：**

事务通常具有以下四个特性，被称为 ACID 特性：

1. **原子性（Atomicity）**：
   - 事务中的所有操作要么全部完成，要么全部不完成。也就是说，事务不可分割，要么成功执行所有操作，要么在出现故障时不执行任何操作。这就像“全有或全无”的原则。
2. **一致性（Consistency）**：
   - 事务开始前和结束后，数据库都处于一致的状态。事务执行前后数据库满足所有的完整性约束。即使在事务执行过程中出现错误或中断，数据库的完整性不会被破坏。
3. **隔离性（Isolation）**：
   - 并发执行的事务相互之间不受干扰，每个事务的执行效果就像它是数据库中唯一操作的一样。即一个事务的执行不应影响其他事务的执行。当多个事务并发执行时，最终的结果应该与它们按某一顺序串行执行时的结果相同。
4. **持久性（Durability）**：
   - 一旦事务提交，它的结果就被永久保存下来，即使系统崩溃或出现其他故障。持久性确保事务的结果是可靠的，并且不会因为系统故障而丢失。

​	**InnoDB引擎通过什么技术来保证事务的这四个特性的呢？**

- 持久性是通过redo log(重做日志)来保证的：
- 原子性是通过undo log(回滚日志)来保证的；
- 隔离性是通过MVCC(多版本并发控制)或锁机制来保证的；
- 一致性则是通过持久性+原子性+隔离性来保证；

## 并行事务会引发什么问题？（脏读、不可重复读、幻读）

在同时并行处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable-read）、幻读（phantom read）的问题。

### 脏读

**如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。**

![图片](https://cdn.xiaolincoding.com//mysql/other/10b513008ea35ee880c592a88adcb12f.png)

因为事务A是还没提交事务的，也就是它随时可能发生回滚操作，**如果在上面这种情**
**况事务A发生了回滚，那么事务B刚才得到的数据就是过期的数据，这种现象就被称**
**为脏读。**

### 不可重复度

**在一个事务内多次读取同一个数据，如果出现「前后两次读到的数据不一样」的情况，就**
**意味着发生了「不可重复读」现象。**

![图片](https://s2.loli.net/2024/08/27/45vJPro9SApdZEb.png)

假设有A和B这两个事务同时在处理，事务A先开始从数据库中读取小林的余额数
据，然后继续执行代码逻辑处理，**在这过程中如果事务B更新了这条数据，并提交了**
**事务，那么当事务A再次读取该数据时，就会发现前后两次读到的数据是不一致的，**
**这种现象就被称为不可重复读。**

### 幻读

**在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后「两次查询到
的记录数量不一样」的情况，就意味着发生了「幻读」现象。**

![图片](https://s2.loli.net/2024/08/27/V8QMvKsmfJbCGku.png)

事务A突然插入了一条数据，并提交了事务，此时事务B读取的记录突然多了一条，前后不一致。

## 事务的隔离级别有哪些？

并行事务可能出现的问题：

- 脏读：读取到其他事务未提交的数据。
- 不可重复读：前后读取的数据不一致。
- 幻读：前后读取的记录数量不一致。

严重性排序：

![图片](https://s2.loli.net/2024/08/27/qe7CnvaIGl1d6Wk.png)

 为此，SQL标准设置了**四种隔离级别**来规避这些情况：

- **读未提交(read uncom㎡nitted)**：指一个事务还没提交时，它做的变更就能被其他事务看到；
- **读已提交(read committed)：**指一个事务提交之后，它做的变更才能被其他事务看到；
- **可重复读(repeatable read)：**指一个事务执行过程中看到的数据，跟这个事务启动时看到的数据是一致的，**MySQL InnoDB引擎的默认隔离级别**；
- **串行化(serializable)**：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

按隔离水平高低排序如下：

![图片](https://s2.loli.net/2024/08/27/jto81u3UTGvDcB4.png)

不同的隔离级别，并行事务时可能发生的现象也不同：

![图片](https://s2.loli.net/2024/08/27/lc2zk3gJ8frH45y.png)

MySQL InnoDB引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了）解决的方案有两种：

- **针对快照读（普通select语句）**，是通**过MVCC方式解决了幻读**，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
- **针对当前读(select.for update等语句)**，是**通过`next-key lock`(记录锁+间隙锁)方式解决了幻读，**因为当执行`select.for update`语句的时候，会加上`next-key lock`,如果有其他事务在next-key lock锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

对于「读已提交」和「可重复读」隔离级别的事务来说，它们是通过**Read View**来实现的，它们的区别在于创建Read View的时机不同，大家可以把Read View理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读已提交」隔离级别是在「每个语句执行前」都会重新生成一个Read View，而「可重复读」隔离级别是「启动事务时」生成一个Read View，然后整个事务期间都在用这个Read View。

**两种启动事务的命令：**

- `begin/start transaction` ：执行完这个命令后，执行了第一条`select`语句，才算启动。
- `start transaction with consistent snapshot`：马上启动事务

# 锁篇

## MySQL有哪些锁？

![img](https://s2.loli.net/2024/08/27/SIg7ebn31fH5NrL.png)

### 全局锁

使用和释放全局锁：

`````
flush tables with read lock  // 使用全局锁
unlock tables  				// 释放全局锁，或者会话断开后，锁会自动释放
`````

执行后，**整个数据库将处于只读状态**，以下操作将不被执行：

- 对数据的增删改操作，`insert、delete、update`
- 对表结构的更改操作，`alter table、drop table`

全局锁庄要应用于做**全库逻辑备份**，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。

使用全局锁，数据库处于只读状态，会造成业务停滞。解决办法：

如果数据库的引擎支持的事务支持可重复读的隔离级别，那么在备份数据库之前先开启事务，会先
创建Read View,然后整个事务执行期间都在用这个Read View,而且由于MVCC的支持，备份期间业务依然可以对数据进行更新操作。

### 表级锁

- 表锁
- 元数据锁（MDL）
- 意向锁
- AUTO-INC锁

#### 表锁

```go
//表级别的共享锁，也就是读锁：对写操作互斥
lock tables t_student read;
//表级别的独占锁，也就是写锁；对读、写操作都互斥
lock tables t_stuent write;
// 主动释放锁，或者等会话结束
unlock tables
```

表锁的颗粒度太大，影响并发性能。

#### 元数据锁（MDL）

#### 意向锁

意向锁的目的是为了快速判断表里是否有记录被加锁。

- 在使用InnoDB引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁；
- 在使用InnoDB引擎的表里对某些纪录加上「独占锁！之前，需要先在表级别加上一个「意向独占锁」；

**意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁(`lock tables…read`)和独占表锁(`lock tables…write`)发生冲突。**

表锁和行锁是满足读读共享、读写互斥、写写互斥的。

#### AUTO-INC锁

### 行级锁

InnoDB 引擎支持行级锁，而MyISAM不支持。

普通的select语句是不会对记录加锁的，因为它属于快照读。如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为锁定读。
```go
//对读取的记录加共享锁
select ..lock in share mode;
//对读取的记录加独占锁
select ..for update;
```

上面这两条语句必须在一个事务中，**因为当事务提交了，锁就会被释放**，所以在使用这两条语句的时候，要加上`begin、start transaction`或者`set autocommit=0。`
**共享锁（S锁）满足读读共享，读写互斥。独占锁（X锁）满足写写互斥、读写互斥。**

![img](https://s2.loli.net/2024/08/27/1cHvhmXknRqluWi.png)

行级锁的类型主要有三类：

- Record Lock（记录锁）：也就是仅仅把一条记录锁上：
- Gap Lock（间隙锁）：锁定一个范围，但是不包含记录本身；
- Next-Key Lock（临键锁）：Record Lock+Gap Lock 的组合，锁定一个范围，并且锁定记录本身。

#### 记录锁（record lock）

记录锁 锁住的是一条记录，而且记录锁也分 共享锁 和 独占锁。

- 事务中对记录加了 S记录锁后，其他事务可以继续对该记录加 S 记录锁，但是不可加 X 记录锁。（S与S兼容，S与X不兼容）
- 事务中对记录加了 X记录锁后，其他事务不可以继续对该记录加 S 记录锁，也不可加 X 记录锁。（X与不S兼容，X与X不兼容）

```go
mysql > begin  // 开启一个事务，或者 start transaction
mysql > select * from t_test where id = 3 for update  // x 记录锁
// 对t_test 表中id为3的这条记录加上了 X记录锁。
// FOR UPDATE 是一种锁定行的方式，通常与 SELECT 语句一起使用来锁定选定的行，以防止其他事务对这些行进行修改。
SELECT * FROM t_test WHERE id = 10 lock in share mode;		// S 记录锁
COMMIT;
```

#### 间隙锁（gap lock）

间隙锁 只存在于「可重复读」隔离级别，目的为了解决可重复读隔离级别下的幻读现象。

<img src="https://s2.loli.net/2024/08/27/Rz4cWvMKf7LbDjF.png" alt="img" style="float : left"/>

其他事务无法插入 `id = 4`的这一条记录，防止幻读的发生。

间隙锁之间是兼容的，即两个事务可以同时特有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻读记录而提出的。

`````sql
START TRANSACTION;
SELECT * FROM t_test WHERE id > 3 AND id < 5 FOR UPDATE;
-- 在这里进行其他操作，例如更新符合条件的行
COMMIT;
`````

#### 插入意向锁：特殊的间隙锁

一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁(next-key lock也包含间隙锁)。

如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个**插入意向锁**，表明有事务想在某个区间插入新记录，但是现在处于等待状态。

插入意向锁是一种特殊的间隙锁，属于行级别锁。如果说间隙锁锁住的是一个区间，那么插入意向锁锁住的就是一个点。

<img src="https://s2.loli.net/2024/08/27/6KNSiPXg5pkyUjB.png" alt="img" style ="float :left"/>

#### `Next-Key Lock`（临键锁）

`nexxt-key lock`是「记录锁+间隙锁」，锁定一个范围，并且锁定记录本身。

<img src="https://s2.loli.net/2024/08/27/Cb7dWUATGfNphEJ.png" alt="img" style="float:left"/>

此时无法插入`id = 4`这条记录，也无法更改 `id = 5`这条记录。

````sql
START TRANSACTION;
SELECT * FROM t_test WHERE id > 3 AND id <= 5 FOR UPDATE;
-- 在这里进行其他操作，例如更新符合条件的行
COMMIT;
````

`next-key lock`是包含**间隙锁+记录锁**的，如果一个事务获取了X型的`next-key lock`,那么另外一个事务在获取相同范围的X型的`next-key lock`时，是会被阻塞的。

## MySQL怎么加行级锁的？

普通的`select`语句是不会对记录加锁的（除了串行化隔离级别），因为它属于快照读，是通过MVCC(多版本并发控制)实现的。

如果要在查询时对记录加行级锁，可以使用下面这两个方式，这两种查询会加锁的语句称为锁定读。
```go
//对读取的记录加共享锁(S型锁)
select ..lock in share mode;
//对读取的记录加独占锁(X型锁)
select ..for update;
```

上面这两条语句必须在一个事务中，因为当事务提交了，锁就会被释放，所以在使用这两条语句的时候，要加上begin或者start transaction开启事务的语句。

除了上面这两条锁定读语句会加行级锁之外，**`update` 和 `delete` 操作都会加行级锁，且锁的类型都是独占锁(X型锁)。**
```go
//对操作的记录加独占锁(X型锁)
update table ...where id 1;
//对操作的记录加独占锁(X型锁)
delete from table where id 1;
```

行级锁加锁规则比较复杂，不同的场景，加锁的形式是不同的。

**【加锁的对象是索引，加锁的基本单位是`next-key lock`】。**`next-key lock`是前开后闭区间，而间隙锁是前开后开区间。

但是，在能使用记录锁或者间隙锁就能避免幻读现象的场景下，`next-keylock`就会退化成记录锁或间隙锁。

**总结下，MySQL行级锁的加锁规则。**
**（1）唯一索引等值查询：**

- 当查询的记录是「存在」的，在索引树上定位到这条记录后，将该记录的索引中的`next-key lock`会退化成「记录锁」。
- 当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后（`id = n`），将该记录的索引中的`next-key lock`会退化成「间隙锁」,锁住的范围为`(1,n)`

**（2）非唯一索引等值查询：**

- 当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是`next-key lock`，而对于第一个不符合条件的二级索引记录，该二级索引的`next-key lock`会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁。
- 当查询的记录「不存在」时，扫到第一条不符合条件的二级索引记录，该二级索引的`next-k©y锁`会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁。

**非唯一索引和唯一索引的范围查询的加锁规则不同之处在于：** 

- 唯一索引在满足一些条件的时候，索引的`next-key lock`退化为间隙锁或者记录锁。
- 非唯一索引范围查询，索引的`next-key lock`不会退化为间隙锁和记录锁。

**其实理解MySQL为什么要这样加锁，主要要以避免幻读角度去分析，**这样就很容易理解这些加锁的规侧了。

**在执行`update、delete、select.for update`等具有加锁性质的语句，定要检查语句是否走了索引，如果查询语句没有采用索引查询，导致扫描是全表扫描的话，会对每一个索弱引加`next-key lock`，相当于把整个表锁住了，这是挺严重的问题。**

>有什么命令可以分析加了什么锁?

`````go
select * from performance_schema.data_locks\G
`````

## MySQL死锁了怎么办？

死锁的四个必要条件：**互斥、占有且等待、不可强占用、循环等待**。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。

在数据库层面，有两种策略通过**「打破循环等待条件」**来解除死锁状态：

- **设置事务等待锁的超时时间**。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在InnoDB中，参数`innodb lock wait timeout`是用来设置超时时间的，默认值时50秒。当发生超时后，就出现下面这个提示：`ERROR 1205 (HY000):Lock wait timeout exceeded;try restarting transaction`

- **开启主动死锁检测。**主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on,表示开启这个逻辑，默认就开启。当检测到死锁后，就会出现下面这个提示：

  `ERROR 1213 (40001):Deadlock found when trying to get lock;try restarting transaction`

上面这个两种策略是「当有死锁发生时」的避免方式。当然我们还可以从业务层面上来避免死锁。

这里有个死锁的例子：

![](https://s2.loli.net/2024/08/27/BdhgtyXcIMk7nsC.jpg)

**分析：**

- `time 1`：事务A对`id 为（20，30）`的j记录加上了 间隙锁。
- `time 2`：事务B对`id 为（20，30）`的记录加上了间隙锁，事务之间的间隙锁兼容，不冲突。
- `time 3`：事务A对想插入`id=25`的记录，但是这个范围被事务B间隙锁锁定了，此时形成了一个插入意向锁，与事务B的间隙锁互斥，因此需要等待事务B释放。
- `time 4`：事务B对想插入`id=26`的记录，但是这个范围被事务A锁定了，此时形成了一个插入意向锁，等待事务A释放。
- 于是造成了互相占有、互相等待对方释放，形成死锁。

# 日志篇
