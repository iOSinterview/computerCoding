



[TOC]





# 基础篇

## MySQL的基础架构

（一条select语句执行的流程）

总体架构图：

![MySQL基础架构](https://s2.loli.net/2024/08/16/uWQtjdp5JeBFvkl.png)

MySQL的架构主要分为两层：Server层和存储引擎层

- **Server层负责建立连接、分析和执行SQL。**主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。
- **存储引擎层负责数据的存储和提取**。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。

**第一步：连接器**

连接器负责跟客户端建立连接、获取权限、维持和管理连接。当身份认证完成以后，如果没有后序操作，连接会进入空闲状态，但`wait_timeout`过期时，连接器会关闭该连接。

连接MySQL服务通过以下命令：

```shell
# -h 指定 MySQL 服务得 IP 地址，如果是连接本地的 MySQL服务，可以不用这个参数；
# -u 指定用户名，管理员角色名为 root；
# -p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码
mysql -h $ip -u$user -p
```

MySQL基于TCP建立连接，因此需要经过TCP三次握手。

MySQL中的来凝结跟HTTP一样，有长短连接，一般是使用长连接，但是长连接过多是会导致内存占用更大，被系统强行杀掉（OOD），即MySQL异常重启。

```c
// 短连接
连接 mysql 服务（TCP 三次握手）
执行sql
断开 mysql 服务（TCP 四次挥手）

// 长连接
连接 mysql 服务（TCP 三次握手）
执行sql
执行sql
....
断开 mysql 服务（TCP 四次挥手）
```

怎么解决这个问题呢？你可以考虑以下两种方案。

1. **定期断开长连接。**使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。
2. **客户端主动重置连接。**可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

总结：

- 与客户端进行 TCP 三次握手建立连接；
- 校验客户端的用户名和密码，如果用户名或密码不对，则会报错；
- 如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；

**第二步：查询缓存**

如果要执行的SQL语句是`select`查询语句，MySQL会先去查询缓存。**但其实查询缓存的命中率非常低，因为对于更新比较频繁的表，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了。**除非业务需要的就是一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。

**需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。**

**第三步：解析器**

在正式执行SQL语句查询前，MySQL中的解析器会先对SQL语句做解析，了解客户端输入的是什么需求，即连接需求。主要会做两件事。

- 解析器先会做`词法分析`。需要识别出里面的字符串分别是什么、代表什么，也就是识别关键字。
- 接着做`语法分析`。根据`词法分析`的结果，`语法分析`会根据语法规则，判断当前的SQL语句是否合法，然后构建语法树，方便后续模块读取表名、字段、语句类型。

**第四步：执行SQL**

接着就要进入执行 SQL 查询语句的流程了，每条`SELECT` 查询语句流程主要可以分为下面这三个阶段：

- prepare 阶段，也就是预处理阶段；
- optimize 阶段，也就是优化阶段；
- execute 阶段，也就是执行阶段；

**预处理阶段**

- 检查 SQL 查询语句中的表或者字段是否存在；
- 将 `select *` 中的 `*` 符号，扩展为表上的所有列；

**优化器**

**优化器主要负责将 SQL 查询语句的执行方案确定下来**，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。

**执行器**

根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；

**总结**

- 连接器：建立、管理连接、校验用户身份；
- 查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；
- 解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；
- 执行 SQL：执行 SQL 共有三个阶段：
  - 预处理阶段：检查表或字段是否存在；将 `select *` 中的 `*` 符号扩展为表上的所有列。
  - 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；
  - 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；

![MySQL基础架构](https://s2.loli.net/2024/08/16/nlGyPqhBbJmT4Xd.png)

## 表空间文件的结构

表空间由段（segment）、区（extent）、页（Page）、行（row）组成，InnoDB存储引擎的逻辑存储结构如下：

![](https://s2.loli.net/2024/08/22/g93cOb1wXmN4LDy.webp)

- 行：数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。
- 页：页是 InnoDB 存储引擎磁盘管理的最小单元，**InnoDB 的数据是按「页」为单位来读写的，默认每个页的大小为 16KB**，常见的有数据页、undo 日志页、溢出页等等。
- 区：在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，二十按照区为单位分配。每个区的大小为 1MB ，对于16KB的页来说，连续的64个页会被划分为一个区，这样就使得链表中相邻页的物理位置页相邻，就能使用顺序I/O。
- 段：表空间由多个段组成，段一般分为数据段、索引段、回滚段。
  1. 数据段：存放B+树中叶子节点的区的集合
  2. 索引段：存放B+树中非叶子节点的区的集合
  3. 回滚段：存放的是回滚数据的区的集合。（MVCC使用回滚实现多版本查询数据）


# 索引篇

## 索引常见面试题

## 什么是索引？有什么作用优势？

在数据库中，索引是一种数据结构，用于提高数据库表中数据的检索速度和查询效率。索引类似于书籍的目录，可以帮助数据库的存储引擎快速定位到包含特定值的行，而不必扫描整个表。

所谓的存储引擎，就是如何存储数据、如何为存储的数据建立索引以及如何更新、查询数据等技术的一个实现方法。MySQL中的存储引擎由MyISAM、InnoDB、Memory。

那么**采用索引主要可以加快数据检索速度、提高查询效率、还可以对表中的某一列进行唯一性约束。**

## 索引的分类？

- 按【数据结构】分类：**B+树索引**、Hash索引、Full-text索引
- 按【物理存储】分类：**聚簇索引（主键索引）**、二级索引（辅助索引）
- 按【字段特性】分类：主键索引、唯一索引、普通索引、前缀索引
- 按【字段个数】分类：单列索引、联合索引

### 数据结构分类

![img](https://s2.loli.net/2024/08/23/RtzvwLAQ7i9O4X6.png)

（上面这个图稍微有印象即可）

在创建表时，InnoDB存储引擎会根据不同的场景选择不同的列作为索引：

- 如果有主键，默认会使用主键作为聚簇索引的索引键(k©y)
- 如果没有主键，就选择第一个不包含NULL值的唯一列作为聚簇索引的索引键(k©y);
- 在上面两个都没有的情况下，InnoDB将自动生成一个隐式自增id列作为聚簇索引的索引键

​       其它索引都属于辅助索引(Secondary Index)，也被称为二级索引或非聚簇索引。创建的主键索引利二级索引默认使用的是B+Tree索引。

### 物理存储分类

从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引），区别如下：

- 主键索引的B+Tree的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的B+Tree的叶子节点里；
- 二级索引的B+Tee的叶子节点存放的是主键值，而不是实际数据。

所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是覆盖索引（只需要差一次B+Tree）。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是回表（查两次B+Tree）。

![回表](https://s2.loli.net/2024/08/23/moqPGOCB7jKn4N5.png)

### 字段特性分类

从字段特性的角度来看的话，分为主键索引、唯一索引、普通索引、前缀索引。

- 主键索引（primary key）：建立在主键字段上的索引，通常在创建表的时候创建，一张表最多只能有一个，且索引列的值不能为NULL。
- 唯一索引（unique key）：一张表可以有多个唯一索引，索引列的值必须唯一，可以为NULL.
- 普通索引（key）：普通字段上索引。
- 前缀索引（）：前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为char、varchar、binary、varbinary的列上。使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。`INDEX(column_name(length))，length为前缀长度`

### 字段个数分类

可以分为单列索引、联合索引。

- 单列索引：建立在单列上的索引。
- 联合索引：建立在多列上，将多个字段组合成一个索引。

使用联合索引时，存在【最左匹配原则】，比如联合索引（a,b），由于索引的前提是key有序，其中a是有序的，b是无序的，如果直接查询`where b = 2`，此时没办法使用来拟合索引。

![img](https://s2.loli.net/2024/08/23/hEFrgz9wdnb814J.png)

联合索弱引的最左匹配原则，在遇到范围查询（如`>、<`）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索弱引，但是在范围查询字段的后面的字段无法用到联合索弱引。注意，对于`>=、<=、BETWEEN、LIKE` 前缀匹配的范围查询，并不会停止匹配。

## 索引优缺点？什么时候需要/不需要索引？

### 索引的缺点

索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：

- 需要占用物理空间，数量越大，占用空间越大；
- 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大，
- 会降低表的增删改的效率，因为每次增删改索引，B+树为了维护索引有序性，都需要进行动态维护。

所以，索引不是万能钥匙，它也是根据场景来使用的。

### 什么时候适用索引？

- 字段有唯一性限制的，比如商品编码；
- 经常用于`WHERE查询条件`的字段，建立索引能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。
- 经常用于`GROUP BY`和`ORDER BY`的字段，这样在查询的时候就不需要再去做一次排序了，因为建立索引之后在**B+Tree**中的记录都是排序好的。

### 什么时候不需要创健索引？

- WHERE条件，GROUP BY，ORDER BY里用不到的字段。索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。
- 字段中存在大量重复数据，不需要创建索引。比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为MySQL还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。
- 表数据太少的时候，不需要创建索引；
- 经常更新的字段不用创建索引。比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护B+Tre的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。

## 有什么优化索引的方法？

- 前缀索引优化；
- 覆盖索引优化；
- 主键索引最好是自增的；
- 防止索引失效；

### 前缀索引优化

前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引，

使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段（比如email邮箱）作为索引时，使用前缀索引可以帮助我们减小索引项的大小。

不过，前缀索引有一定的局限性，例如：

- order by就无法使用前缀索引，因为order by需要的是整个字段的排序顺序。
- 无法把前缀索引用作覆盖索引。因为覆盖索引是指查询所需的所有数据都在索引中，可以完全通过索引来获取结果，而无需访问表数据。前缀索引因为只索引了字段的前部分，因此无法作为覆盖索引来使用。

### 覆盖索引优化

覆盖索引就是从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表。

假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？
我们可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。

所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少
了大量的/O操作。

### 主键索引最好自增

因为InnoDB创建主键索引默认使用聚簇索引，数据都会被存放在B+Tree的叶子节点上，也就是说，同一个叶子节点内的各个数据都是按主键顺序存放的。

**如果我们使用自增主键，那么每次插入一条新纪录，都是追加操作，不需要重新移动数据，这种插入数据的方法非常高效。**

如果非自增主键，每次插入主键的索引是随机的，可能会插入到某个数据页的中间位置，需要移动其他的数据来满足新数据的插入，页空间不够会造成【页分裂】，可能会造成大量内存碎片，导致索引结构不紧凑，影响查询效率。

**另外，主键字段的长度不要太大，因为主键字段长度越小，意味着二级索引的叶子节点越小（二级索3引的叶子节点存放的数据是主键值），这样二级索3引占用的空间也就越小。**

### 索引最好设置为  `NOT NULL`

有以下两个原因：

- 索引列存在`NULL`就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为`NULL`的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count会省略值为`NULL`的行。
- `NULL` 值虽然是一个没意义的值，但是它也会占用物理空间（InnoDB行格式中至少会使用一个字节存储`NULL`值列表）。

### 防止索引失效

用上了索引并不意味着查询的时候会使用索引，因此我们要避免索引失效。

## 什么时候索引会失效？

- 当我们使用左或者左右模糊匹配的时候，也就是like %xx 或者like%xx%这两种方式都会造成索引失效；
- 当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；
- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
- 在WHERE子句中，如果在OR前的条件列是索引列，而在OR后的条件列不是索引列，那么索引会失效。
- 为了更好的使用索引，索引列要设置为`NOT NULL`约束。

## 为什么MySQL采用B+Tree作为索引？

首先什么样的数据结构适合硬座索引呢？至少要满足以下需求：

1. **要尽可能少的磁盘I/O操作完成查询操作。**
2. **既能高效地查询某一个记录，也能高效地执行范围查找。**因此索引的数据最好有序，这样可以使用**【二分查找】**高效定位数据。

首先想到是【有序数组】，但是有序数组在进行插入数据的时候效率非常低。

于是我们想到了**【二叉查找树】**，**它的特点是左子树小于根节点，右子树大于根节点**，但是如果每次都是插入最大/小的元素，那么就会像一个链表，查询效率（I/O操作）从`O(logn)`升至`O(n)`。于是出现了**【平衡二叉查找树（AVL）】**，其实就是加了一个约束：**每个节点的左子树和右子树的高度差不能超过1。**查询侠侣维持在`O(logn)`。但是二叉树每个节点最多只有两个孩子，当数据非常多的时候，树会非常高，查询效率会下降。

为了降低树的高度，因此想到了**【多叉平衡查找树】**，首先是 **【B Tree】。**

**B树的特点：**

- 每个节点最多有M个子树，所有非叶节点至少有$\frac{M}{2}$颗子树，每层允许M-1个关键字。
- 每个节点包含了（索引+记录），所有叶子节点在同一层。

虽然B树降低了树的高度，提高了查询效率，但是它的每个节点都包含了索引+记录，如果当我们查询的【记录A】层数较深，那么查询过程中【非A记录节点】里的记录也会从磁盘加载到内存，而我们知识需要索引，这样不仅增加了 I/O 操作次数，也会占用内存。并且B树如果要进行范围查询，需要中序遍历，设计多个节点的磁盘 I/O 问题，效率比较低。

于是对B树进行了升级，得到了 【B+Tree】，特点如下：

- 叶子节点才会存放实际数据（索引+记录），非叶子节点只会存放索引，节约内存。
- 所有索引都会在叶子节点出现，叶子节点之间构成一个双向有序俩表，方便范围查询。
- 非叶子节点的索引也会存在于子节点中，并在子节点中有序（最大/最小索引）。

![图片](https://s2.loli.net/2024/08/23/JYLgu3a1UVkIoxt.png)

## 小结

![img](https://s2.loli.net/2024/08/23/J1RPsCAUOow4mD9.png)

# 事务篇

# 锁篇
