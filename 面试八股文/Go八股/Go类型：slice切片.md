## Go类型：slice切片

---

## Go 语言当中array和slice的区别是什么？

**数组：**

- **数组固定长度**。数组长度是数组类型的一部分，所以[3]int 和[4]int 是两种不同的数组类型，数组需要指定大小，不指定也会根据初始化，自动推算出大小，大小不可改变。
- **数组是通过值传递的**

**切片：**

- 切片可以改变长度。切片是轻量级的数据结构，三个属性：指针、长度、容量。不需要指定大小。
- 切片是地址传递（引用传递），可以通过数组来初始化，也可以通过make()来初始化，初始化的时候 len=cap，然后进行扩容。
- **切片看上去是引用传递，但其实是值传递**。当你传递一个切片时，实际上传递的是这个切片结构的副本，**包括指向底层数组的指针、长度和容量。**

**简洁的回答**：

1. 定义方式不一样。
2. 初始化方式不一样，数组需要指定大小，大小不改变。
3. 在函数传递中，数组切片都是值传递。

## Go 语言是如何实现slice扩容的？扩容策略是什么？

切片扩容通常是在进行切片的 append 操作时触发的。在进行 append 操作时，如果切片容量不足以容纳新的元素，就需要对切片进行扩容，此时就会调用 growslice 函数进行扩容。
切片扩容分两个阶段，分为 go1.18 之前和之后：

（1）go1.18 之前：

- 首先判断，如果期望容量大于当前容量的两倍，新容量则为期望容量；

- 否则判断，如果当前切片的长度小于 1024，新容量是旧容量的两倍；

- 否则判断，如果当前切片的长度大于 1024 ，每次增加 25% 的容量，直到新容量大于期望容量；

**（2）go1.18 之后：使底层数组扩容系数增长的更加平滑。**

- **首先判断，如果期望容量大于当前容量的两倍，新容量就是期望容量；**
- **否则判断，如果当前切片的长度小于阈值（默认 256），新容量是旧容量翻倍；**
- **否则判断，如果当前切片的长度大于等于阈值（默认 256），就会每次增加基准值25% 的容量，基准是 newcap + 3*threshold（256），直到新容量大于期望容量；**

![切片扩容公式](https://s2.loli.net/2024/08/03/a43ZWNJxmhrdDyI.png)

总的来说，Go的设计者不断优化切片扩容的机制，其目的只有一个：**就是控制让小的切片容量增长速度快一点，减少内存分配次数，而让大切片容量增长率小一点，更好地节省内存。**

## 扩容前后的slice是否相同？

这要分情况来看，主要看底层数组有没有改变：

- 如果原数组还有容量是可以进行扩容的，那么扩容以后的数组还是会指向原来的数组，对一个slice的操作可能会影响多个指针指向相同地址的slice。

- 如果原来数组的容量已经不足以扩容，那么Go默认先开一片内存区域，再把原来的值先拷贝过来，然后再执行`append()`操作。此时由于底层数组变了，不会影响原数组。
- 复制一个slice，最好使用`Copy`（浅拷贝）函数

## slice的底层实现？

- **slice 是基于数组实现的，**他的底层是数组，它本身非常小，主要由指针、长度、容量三个字段组成，**是对底层数组的一个抽象。**
- 由于slice基于数组实现，所以它的**底层内存是连续分配的，可以通过索引获得数据**，效率很高。
- slice 本身并不是动态数组或者数组指针，其**内部的数据结构是通过指针引用底层数组，**将数据读写操作限定在指定区域内。