# 逃逸分析，变量何时栈？何时堆？

---

在Go语言中，变量的内存分配可以发生在栈（stack）或堆（heap）上，具体取决于变量的作用范围和生命周期。了解何时分配在栈上，何时分配在堆上，可以帮助优化程序性能，特别是内存使用和垃圾回收的开销。

 go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做**逃逸分析(escape analysis)**，**当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆**。 go语言声称这样可以释放程序员关于内存的使用限制，更多的让程序员关注于程序功能逻辑本身。

### 1. **栈（Stack）分配**

栈是一块连续的内存区域，用于存储函数调用中的局部变量。栈的内存分配非常高效，具有以下特点：

- **自动分配和释放**：当函数调用时，栈帧（stack frame）会被分配，用于存储局部变量。当函数返回时，栈帧会自动被回收。
- **生命周期短暂**：栈上的变量的生命周期由函数调用的生命周期决定，它们在函数结束后会被回收。
- **高效**：栈内存分配和释放的代价很低，因为它是自动进行的。

#### 什么时候分配在栈上？

- **局部变量**：函数内声明的局部变量在不需要在函数返回后继续存在的情况下，会分配在栈上。
- **小对象**：一般来说，Go编译器会倾向于将小的、生命周期短的对象分配在栈上。

#### 示例：

```
func sum(a, b int) int {
    result := a + b  // 局部变量 result 分配在栈上
    return result
}
```

在上面的例子中，`result` 是一个局部变量，它的生命周期与函数 `sum` 的调用过程一致，因此它被分配在栈上。

### 2. **堆（Heap）分配**

堆是用来存储动态分配的内存块。与栈不同，堆内存不会随着函数调用结束而自动释放。**Go通过垃圾回收器（GC）管理堆内存**。分配在堆上的变量具有以下特点：

- **手动分配和自动回收**：堆上的内存由垃圾回收器负责回收，分配的变量在它们不再被引用时，才会被回收。
- **生命周期较长**：如果一个变量需要在函数返回后继续存在，或者它的引用被传递到外部，它就需要分配在堆上。
- **性能开销较大**：堆上的分配和垃圾回收会带来一些性能开销，尤其是频繁分配和释放大量堆内存时，可能会对性能产生影响。

#### 什么时候分配在堆上？

- **逃逸分析**：Go编译器通过**逃逸分析**（Escape Analysis）来判断一个变量是否应该分配在堆上。即，当一个变量的引用逃出了它的作用范围（比如局部变量的地址被传递到外部，函数返回后仍需要访问该变量时），该变量会被分配到堆上。
- **全局变量**：全局变量和包级别的变量通常分配在堆上，因为它们的生命周期超出函数调用的范围。
- **闭包中的变量**：闭包（closure）会捕获外部变量，如果这些变量的生命周期超出函数调用，它们也会被分配在堆上。

#### 示例：

```go
func createPointer() *int {
    a := 10       // a 的地址会被返回
    return &a     // 因为 a 的地址被返回，所以 a 逃逸到堆上
}
```

在这个例子中，`a` 是局部变量，但因为它的地址被返回，函数 `createPointer` 结束后，`a` 仍然需要存在，因此它会被分配到堆上。

### 3. **逃逸分析的概念**

**Go 编译器在编译代码时会进行逃逸分析，判断变量是否需要逃逸到堆上。当编译器无法确定一个变量的作用范围时，它可能会选择将该变量分配到堆上，以避免潜在的内存问题。**

#### 逃逸分析的常见场景：

- **传递引用**：如果一个局部变量的引用（指针、切片、map 等）被传递给其他`Goroutine`或返回给调用者，编译器会将这个变量分配到堆上。
- **闭包捕获变量**：如果一个函数中的局部变量被闭包捕获，并且闭包在函数返回后仍然被使用，该变量需要逃逸到堆上。

#### 示例：

```go
func capture() func() int {
    x := 100     // x 将逃逸到堆上
    return func() int {
        return x  // 闭包捕获了 x
    }
}
```

在上面的代码中，`x` 被闭包捕获，且闭包可能在函数 `capture` 返回后还会被调用，因此 `x` 需要分配在堆上。

### 4. **栈和堆的性能差异**

- **栈分配速度更快**：栈上的内存分配和回收都非常快速，且不需要垃圾回收器的介入。因此栈上的变量通常比堆上的变量更高效。
- **堆分配带来的开销**：堆内存的分配需要更复杂的管理，且依赖垃圾回收机制。这意味着频繁分配和释放堆内存可能会影响程序性能，特别是在高并发或长时间运行的程序中。

### 5. **如何优化堆和栈的分配**

- **减少不必要的堆分配**：尽量避免不必要的逃逸。通过分析程序的逃逸情况（使用 `go build -gcflags="-m"` 命令查看逃逸分析结果），可以了解哪些变量逃逸到堆上，并通过调整代码来减少堆分配。
- **局部化变量**：尽量使变量的作用范围局限在函数内部，减少变量逃逸的可能性。
- **闭包捕获问题**：避免闭包不必要地捕获外部变量，可以减少堆分配。

### 总结：

- **栈分配**：用于局部变量，生命周期与函数调用一致，分配和释放快速，适用于短期存在的变量。
- **堆分配**：用于需要在函数返回后继续存在的变量或全局变量，或者编译器通过逃逸分析判断需要在堆上分配。堆内存的管理由垃圾回收器负责，可能会带来额外的性能开销。

通过理解栈和堆的分配机制以及逃逸分析，开发者可以编写更高效的Go代码，优化内存使用和性能。