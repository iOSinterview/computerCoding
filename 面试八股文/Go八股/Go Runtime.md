[TOC]

# Go Runtime

# 1、goroutine定义

​		Golang 在语言级别支持协程，称之为 Goroutine，它是 Go 语言中并发编程的基本单位，是一种轻量级的线程。Golang 标准库提供的所有系统调用操作(包括所有的同步 I/O 操作)，都会出让 CPU 给其他 Goroutine。这让 Goroutine 的切换管理不依赖于系统的线程和进程，也不依 赖于 CPU 的核心数量，而是交给 Golang 的运行时统一调度，即GMP调度模型。

# 2、GMP指的是什么？

​		GMP是Go的调度模型，可以有效地利用多核处理器、实现并发执行，避免了传统线程模型中的线程创建和切换的开销，从而提供了高效、简洁的并发编程方式。

- G（Goroutine，协程）：即协程，为用户级的轻量级线程，每个 Goroutine 对象中的 sched（调度器） 保存着其调度相关的上下文信息。

- M（Thread Manager，线程管理器）：是对内核级线程的封装，负责管理操作系统线程和 Goroutines 之间的关系。Go 运行时会动态管理 M 的数量，并根据负载情况进行调整。

- P（Processor，处理器）：用来调度 G 和 M 之间的关联关系。 P 维护一个 Goroutine 队列，当一个 M 空闲时，会从队列中获取 Goroutine 来执行。其数量可通过 GOMAXPROCS()来设置，默认为核心数。

  <img src="https://s2.loli.net/2024/08/06/PniuRgbdGUNLJxZ.png" alt="GMP含义" style="zoom:33%;" />

# 3、调度模型

 		单进程时代不需要调度器，多进程/线程时代有了并发，为了更好地利用CPU才有了调度器需求。

## （1）线程与协程

​		多进程、多线程已经提高了系统的并发能力，但是在高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存。

大量的进程/线程出现了新的问题

- 高内存占用
- 频繁的线程切换调度会消耗大量的CPU资源。

但是，线程又分为”内核态线程“和”用户态线程“，其中，我们把”用户态线程“称之为协程，即Go中的goroutine。一个协程必须要绑定一个线程，CPU运行的是一个”内核态线程“。

<img src="https://s2.loli.net/2024/08/06/r4M1veiwDIApqbg.png" alt="协程与线程" style="zoom: 33%;" />

协程与线程具有三种映射关系：

- 1-1：最容易实现，但是协程的创建、删除、切换均由CPU完成，浪费资源。
- N-1：**协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速**。但是不能发挥CPU多核的能力。
- N-M：几何以上优点，但是实现比较复杂

​		协程跟线程调度是有区别的，**线程由CPU调度是抢占式的**，**协程由用户态调度是协作式的**，一个协程让出CPU后，才执行下一个协程。

## （2）goroutine

**Go为了提供更容易使用的并发方法，使用了goroutine和channel**。goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被`runtime`调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。

goroutine它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多内容，`runtime`会自动为goroutine分配。

goroutine特点：

- 占用内存更小（几kb）
- 调度更灵活(runtime调度)

## （3）1.0之前的GM调度模型（被废弃）

M想要执行、放回G都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥/同步，所以全局G队列是有互斥锁进行保护的。

老调度器有几个缺点：

1. 创建、销毁、调度G都需要每个M获取锁，这就形成了**激烈的锁竞争**。
2. M转移G会造成**延迟和额外的系统负载**。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了**很差的局部性**，因为G’和G是相关的，最好放在M上执行，而不是其他M’。
3. 系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。

![GM调度模型](https://s2.loli.net/2024/08/06/HRE3DUo7AMyCX8S.png)

# 4、GMP模型简介

面对之前老的GM调度器的问题，Go设计新的调度器，再G跟M的基础上，引入了P（即Processor调度器），这个P，它包含了运行goroutine的资源，如果M想要运行G，必须先获取P，并且P中包含了可运行的G队列。

![GMP调度器模型](https://s2.loli.net/2024/08/06/74YuhPTjwkW91Ac.jpg)

1. **全局队列**（Global Queue）：存放等待运行的G。
2. **P的本地队列**：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。
3. **P列表**：所有的P都在程序启动时创建，并保存在数组中，最多有`GOMAXPROCS`(可配置)个。
4. **M**：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列**拿**一批G放到P的本地队列，或从其他P的本地队列**偷**一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。

**Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行**。

# 5、P与M的个数及创建问题

> **有关P和M的个数问题**

1、P的数量：

- 由启动时环境变量`$GOMAXPROCS`或者是由`runtime`的方法`GOMAXPROCS()`决定。这意味着在程序执行的任意时刻都只有`$GOMAXPROCS`个goroutine在同时运行。

2、M的数量：当前OS分配到当前Go程序的内核线程数

- go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000，但是内核很难支持这么多的线程数，所以这个限制可以忽略。
- runtime/debug中的SetMaxThreads函数，设置M的最大数量
- 一个M阻塞了，会创建新的M，如果有M空闲，会被回收或者睡眠。

M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。

> #### P和M何时会被创建

1、P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。

2、M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。

# 6、调度器设计策略

## （1）复用线程

首先，GMP的一个调度器的设计策略是**复用线程**，就是避免频繁的创建、销毁线程，而是对线程的复用。

### <1>  work stealing（工作窃取）

当前 M 无可运行的 G 时，尝试从其他 M' 绑定的 P 偷取 G ，而不是销毁线程 M 。

<img src="https://s2.loli.net/2024/08/10/ouUbeKWcNFRhaXA.png" alt="image-20240810153645185" style="zoom: 50%;" />

### <2> hand off （分离机制）

- 当一个M正在执行G1进行的系统调用被阻塞，会创建/唤醒一个M‘。
- M 释放绑定的P，将其交给其他的M执行。
- 原来的M 此时不工作，当G1执行完后会进入睡眠或者销毁。
- 细节：当发生上下文切换时，需要对执行现场进行保护，以便下次被调度执行 时进行现场恢复。Go 调度器 M 的栈保存在 G 对象上，只需要将 M 所需要的寄存器（SP、PC 等）保存到 G 对象上就可以实现现场保护。当这些寄存器数据被保 护起来，就随时可以做上下文切换了，在中断之前把现场保存起来。如果此时 G 任务还没有执行完，M 可以将任务重新丢到 P 的任务队列，等待下一次被调度 执行。当再次被调度执行时，M 通过访问 G 的 vdsoSP、vdsoPC 寄存器进行现场恢复（从上次中断位置继续执行）。

<img src="https://s2.loli.net/2024/08/10/jupHeA4vPOK7Uo1.png" alt="image-20240810155754932" style="zoom: 25%;" />

<img src="https://s2.loli.net/2024/08/10/MNgvnsTlVA5EfFJ.png" alt="image-20240810161420754" style="zoom: 50%;" />

## （2）利用并行

最多有GOMAXPROCS个线程分布在多个CPU上执行。`GOMAXPROCS = 核数/2`

## （3）抢占式调度

在coroutine中要等待一个协程主动让出CPU才执行下一个协程，垃圾回收需要暂停整个程序（Stop-the-world，STW），最长可能需要几分 钟的时间，导致整个程序无法工作。

在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死。

## （4）全局G队列

当M执行work stealing时，从其他P偷不到G时，可以从全局队列中获取G。

# 7、GMP调度过程

![2、Golang的协程调度器原理及GMP设计思想？ - 图14](https://s2.loli.net/2024/08/10/bAG3d2FHTv1zeuP.jpg)

-  1、我们通过 go func()来创建一个goroutine；

-  2、有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；

-  3、G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；

-  4、一个M调度G执行的过程是一个循环机制；

-  5、当M执行某一个G时候如果发生了syscall或则其余阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P；

-  6、当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。

# 8、调度器（函数）的生命周期

![2、Golang的协程调度器原理及GMP设计思想？ - 图15](https://s2.loli.net/2024/08/10/v7dyslNiBVWkb24.png)

<img src="https://s2.loli.net/2024/08/10/RYn9sqMm6Ze3yCl.png" alt="image-20240810170020279" style="zoom:50%;" />



<img src="https://s2.loli.net/2024/08/10/Ipr7D1J6mfjuQCd.png" alt="image-20240810170053946" style="zoom:50%;" />

# 9、特殊的M0和G0

**`M0`是启动程序后的编号为0的主线程**

- 这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，
- M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。

**`G0`是每次启动一个M都会第一个创建的gourtine**

- G0仅用于负责调度的G，
- G0不指向任何可执行的函数，
- 每个M都会有一个自己的G0。
- 在调度或系统调用时会使用G0的栈空间，全局变量的G0是M0的G0。

# 10、GMP 调度过程中存在哪些阻塞 

-  I/O，select 
-  syscall（系统调用）
-  channel 
- 等待锁 
- runtime.Gosched()：`runtime.Gosched()` 是 Go 运行时提供的函数，用于手动触发一次调度，让其他 Goroutine 有机会执行。

# 11、什么是GC？有什么作用？

`GC`是垃圾回收，全称`Garbage Collection`，是一种自动的内存管理机制。

当程序向操作系统申请的内存不需要时，`GC`主动将其回收归还给操作系统，或者提供其他程序进行内存申请时复用。

`GC`对程序员透明，程序员不需要对内存进行手动的申请和释放。

# 12、Go中的GC垃圾回收机制

## （1）Go v1.3 之前的标记清除（mark and sweep）

- 启动STW（stop the world），暂停程序逻辑，找出可达对象和不可达对象。

- 开始标记，给可达对象做上标记。

- 清除未标记的对象。

- 停止STW，让程序继续运行，循环这个过程，直至程序生命周期结束。

  <img src="https://s2.loli.net/2024/08/12/OeX5IHZ14rnDsGU.png" alt="image-20240812175251450" style="zoom: 50%;" />

缺点：

- STW：程序暂停，程序出现卡顿。（最严重）
- 标记需要扫描整个heap。
- 清除数据会产生heap碎片。

## （2）Go v1.5 三色标记法（白-灰-黑）

三种颜色含义：

白色：没有遍历的；灰色：临时状态（最后应为空）；黑色：彻底遍历的

- 程序起初创建时，全部标记为白色，将其放入白色集合中。
- 将程序的根节点集合展开，遍历Root Set，往下走一层，得到灰色节点（对象1、4）。
- 遍历灰色标记表，将可达对象从白色—>灰色，遍历后的灰色，标记为黑色。
- 循环上一步，直至灰色标记表中无对象。
- 清除所有的白色对象（垃圾）。

三色标记法特点：动态逐层遍历，而不是之前的一次性遍历。

![image-20240812175658097](https://s2.loli.net/2024/08/12/cvt6dL29HAqNXim.png)

   如果没有STW保护，此时程序不会暂停，可能会出现下面的情况。

![image-20240812181357392](https://s2.loli.net/2024/08/12/qnMKrx7pzowFlgt.png)

最简单的方式就是添加STW，但是STW有明显的资源浪费，对所有的用户程序都有较大影响。

如何能保证**对象不丢失**的情况下尽可能**提高GC效率**，**减少STW时间**呢？

## （3）Go v1.8 三色标记法+ 混合写屏障机制（**）

### 前言：强弱三色不等式

​	目的是为了破坏前面的两个条件：

- 黑色引用了白的。
- 灰色同时丢失了白色。

<img src="https://s2.loli.net/2024/08/12/4gbfy2KLeBrZhn6.png" alt="image-20240812182427930" style="zoom: 33%;" />

<img src="https://s2.loli.net/2024/08/12/hIzUjvnqeNgmt1K.png" alt="image-20240812182812166" style="zoom: 67%;" />

如果满足强/弱之一，即可保证对象不丢失，Go采用了一种屏障机制来实现。所谓屏障，就是在正常的程序运行过程中，增加一种额外的判断机制。

### 插入写与删除写屏障机制：

1. 插入写屏障：对象被引用时触发。

   - **当A对象引用B对象时，B被强制标记为灰色。（满足强三色不等式，不存在黑色对象引用白色对象。）**
   - 为了保证栈的效率，Go中栈的对象不触发插入屏障，分配在堆的对象才会触发。
   - 但是在准备回收白色前，会重新遍历扫描一次栈空间，加STW保护栈，并进行一次三色标记，直到没有灰色节点。
   - 再停止STW，回收白色。

   ![image-20240812185134211](https://s2.loli.net/2024/08/12/ETUcZAIVkJhdpOe.png)

2. 删除写屏障：对象被删除时触发。

   - **被删除的对象，如果是灰色或者白色，都会被标记为灰色。（满足弱三色不等式，保证灰的到白的路径不会断。）**
   - 回收精度较低，一个应该被删除的对象会活过这一轮，在下一轮GC中被回收掉。

### 混合写屏障操作流程：

- GC刚开始时，全部默认为白色。
- 三色标记法，优先扫描全部栈的对象，将可达对象标记为黑色。（这样做的好处是不需要再进行二次扫描，无需STW。）
- GC期间，任何再栈上创建的新对象，都标记为黑色。
- 被删除的对象标记为灰色。
- 被添加的对象标记为灰色。

混合写屏障满足了**变形的弱三色不等式**，结合了插入、删除屏障的优点。

# 13、GC触发时机？

- 主动触发：调用`runtime.GC`
- 被动触发：
  1. 使用系统监控，由`runtime`中的一个变量控制，默认为两分钟，超过两分钟没有GC时会强制触发GC。
  2. 使用步调（Pacing）算法，核心思想时控制内存增长的比例。

# 14、Go中的GC流程？

当前版本的 Go 以 STW 为界限，可以将 GC 划分为五个阶段：

|       阶段       |                            说明                            | 赋值器状态 |
| :--------------: | :--------------------------------------------------------: | :--------: |
| SweepTermination | 清扫终止阶段，为下一个阶段的并发标记做准备工作，启动写屏障 |    STW     |
|       Mark       |         扫描标记阶段，与赋值器并发执行，写屏障开启         |    并发    |
| MarkTermination  |    标记终止阶段，保证一个周期内标记任务完成，停止写屏障    |    STW     |
|      GCoff       |    内存清扫阶段，将需要回收的内存归还到堆中，写屏障关闭    |    并发    |
|      GCoff       |    内存归还阶段，将过多的内存归还给操作系统，写屏障关闭    |    并发    |

# 15、如何观察GC?

- ### `GODEBUG=gctrace=1`

- ### `go tool trace`

- ### `debug.ReadGCStats`

- ### `runtime.ReadMemStats`

# 16、GC调优？

## （1）GC关注的指标

- CPU 利用率：回收算法会在多大程度上拖慢程序？有时候，这个是通过回收占用的 CPU 时间与其它 CPU 时间的百分比来描述的。

- GC 停顿时间：回收器会造成多长时间的停顿？目前的 GC 中需要考虑 STW 和 Mark Assist 两个部分可能造成的停顿。
- GC 停顿频率：回收器造成的停顿频率是怎样的？目前的 GC 中需要考虑 STW 和 Mark Assist 两个部分可能造成的停顿。
- GC 可扩展性：当堆内存变大时，垃圾回收器的性能如何？但大部分的程序可能并不一定关心这个问题。

## （2）GC如何调优？

通过 go tool pprof 和 go tool trace 等工具 

- 控制内存分配的速度，限制 Goroutine 的数量，从而提高赋值器对 CPU  的利用率。 
- 减少并复用内存，例如使用 sync.Pool 来复用需要频繁创建临时对象，例 如提前分配足够的内存来降低多余的拷贝。 
- 需要时，增大 GOGC 的值，降低 GC 的运行频率。



