## Go的`sync`包中的锁

---

## 互斥锁：`Mutex`

### 简介

**互斥锁是并发程序中对共享资源惊醒访问控制的主要手段，**对此 Go 语言提供了非常简单医用的 Mutex，Mutex为一结构体类型，对外暴露两个方法 `Lock()` 和 `Unlock()` 分别用于加锁和解锁。Mutex 使用起来非常方便，但其内部实现却非常复杂的多，这包括 Mutex 的几种状态。另外，我们也想研究一下 Mutex 重复解锁引起 panic 的原因。

### Mutex 数据结构

源码包 `src/sync/mutex.go:Mutex` 定义了互斥锁的数据结构：

```go
type Mutex struct {
    state int32
    sema  uint32
}
```

- Mutex.state 表示互斥锁的状态，比如变量被锁定。
- Mutex.sema 表示信号量，协程阻塞等待该信号量，解锁的协程释放信号量，从而等待的协程接收信号量。

### Mutex 状态

我们看到 Mutex.state 是32为的整型变量，内部实现时该变量分成四份，用于记录Mutex 的四种状态。

- Locked：表示该Mutex是否已被**锁定**， 0：没有锁定；1：已被锁定；
- Woken：表示是否有协程已被**唤醒**；0：没有协程唤醒；1：已有协程唤醒，正在加锁过程中。
- Starving： 表示该Mutex是否处于**饥饿状态**；0：没有饥饿；1：饥饿状态，**说明有协程阻塞了超过1ms。**
- Waiter：**表示阻塞等待锁的协程个数**，协程解锁时根据此值来哦按断是否需要释放信号量。

![43](assets/43.png)

### Mutex方法

Mutex 对外提供两个方法，实际上也只有这两个方法：

- Lock()：加锁方法；加锁过程会去判断Locked标志位是否为0，如果是0则把Locked位置1，代表加锁成功。当协程B对一个已被占用的锁（Locked=1）再次加锁时，Waiter 计数器增加了1，此时协程B将被阻塞，直到Locked值为 0 后才会被唤醒。
- Unlock()：解锁方法；如果没有其他协程阻塞等待加锁，所以此时解锁时只需要把Locked位置设置为0即可，不需要释放信号量。如果有阻塞，协程A解锁过程分为两个步骤，一是把Locked位置设置 0 ，二是查看到 Waiter > 0，所以释放一个信号量，唤醒一个阻塞的协程，被唤醒的协程 B 把 Locked 位置设置 1，于是协程 B 获得锁。

### 自旋过程

 加锁时，如果当前 Locked 位为 1，说明该锁当前由其他协程持有，**尝试加锁的goroutine并不是马上转入阻塞，而是会持续的探测 Locked 为是否变为 0，这个过程即为自旋过程。**自旋时间很短，但如果在自旋过程中发现锁已被释放，那么协程可以立即获取锁。此时即便有协程被唤醒也无法获取锁，只能再次阻塞。

自旋的好处是，**更充分的利用CPU，尽量避免协程切换，当加锁失败时不必立即转入阻塞，有一定机会获取到锁，这样可以避免协程的切换。**

加锁时程序会自动判断是否可以自旋，无限制的自旋将会给CPU带来巨大压力，所以判断是否可以自旋就很重要了。

### 自旋的条件：

如果 Goroutine 占用锁资源的时间比较短，那么每次都调用信号量来阻塞唤起 goroutine，将会很**浪费**资源。

因此在符合一定条件后，mutex 会让当前的 Goroutine 去**空转** CPU，在空转完后再次调用 CAS 方法去尝试性的占有锁资源，直到不满足自旋条件，则最终会加入到等待队列里。

自旋条件：

-   **锁已被占用，并且锁不处于饥饿模式。** 
-   **积累的自旋次数小于最大自旋次数（active_spin=4）。** 
-   **CPU 核数大于 1。** 
-   **有空闲的 P。** 
-   **当前 Goroutine 所挂载的 P 下，本地待运行队列为空。**

但是，如果加锁的协程特别多，每次都通过自旋获得锁，那么之前被阻塞的协程将很难获得锁，从而进入**饥饿状态。**

为了避免协程长时间无法获取锁，自1.8版本以来增加了一个状态，即Mutex的Starving状态。这个状态下不会自旋，一旦有协程释放锁，那么一定会唤醒一个协程并成功加锁。。

### Mutex 模式

#### 1、正常模式（normal）

默认情况下，Mutex 的模式为 normal。

该模式下，协程如果加锁不成功不会立即装入阻塞排队，而是判断是否满足自旋的条件，如果满足则会启动自旋过程，尝试抢锁。

##### 2、饥饿模式（starvation） 

自旋过程中能抢到锁，一定意味着同一时刻有协程释放了锁，我们知道释放锁时如果发现有阻塞等待的协程，还会释放一个信号量来唤醒一个等待协程，被唤醒的协程得到cpu后开始运行，此时发现锁已被抢占了，自己只好再次阻塞，不过阻塞前会判断自上次阻塞到本次阻塞经过了多长时间，如果超过 1 ms 的话，会将 Mutex 标记为 "饥饿" 模式，然后在阻塞。

**处于饥饿模式下，不会启动自旋过程，也即一旦有协程释放了锁，那么一定会唤醒协程，被唤醒的协程将会成功获取锁，同时也会把等待计数减1.**

#### 3、woken状态

Woken状态用于加锁和解锁过程的通信，举个例子，同一时刻，两个协程一个在加锁，一个在解锁，在加锁的协程可能在自旋过程中，此时把Woken标记为1，用于通知解锁协程不必释放信号量了，好比在说：你只管解锁好了，不必释放信号量，我马上就拿到锁了。

## 读写锁：`RWMutex`

有的情况下不需要使用`Mutex`，因为`Mutex`是所有操作都是互斥的，性能较差；如果当读操作比较多，而写操作比较少的时候，我们可以使用读写锁`RWMutex`，它允许多个goroutine可以同时读。

### `RWMutex`特点

- RWMutex 是单写多读锁，该锁可以加多个读锁或者一个写锁 
- **读锁占用的情况下会阻止写，不会阻止读，多个 Goroutine 可以同时获取读锁** 
- **写锁会阻止其他 Goroutine（无论读和写）进来，整个锁由该 Goroutine  独占** 
- **适用于读多写少的场景** 
- RWMutex 类型变量的零值是一个未锁定状态的互斥锁
- RWMutex 在首次被使用之后就不能再被拷贝 
- RWMutex 的读锁或写锁在未锁定状态，解锁操作都会引发 panic 
- RWMutex 的一个写锁去锁定临界区的共享资源，如果临界区的共享资源已被（读锁或写锁）锁定，这个写锁操作的 goroutine 将被阻塞直到解锁 
- **RWMutex 的读锁不要用于递归调用，比较容易产生死锁。**
- RWMutex 的锁定状态与特定的 goroutine 没有关联。一个 goroutine 可以 RLock（Lock），另一个 goroutine 可以 RUnlock（Unlock） 
- 写锁被解锁后，所有因操作锁定读锁而被阻塞的 goroutine 会被唤醒，并都可以成功锁定读锁 
- 读锁被解锁后，在没有被其他读锁锁定的前提下，所有因操作锁定写锁而被阻塞的 Goroutine，其中等待时间最长的一个 Goroutine 会被唤醒

### RWMutex实现

```go
type RWMutex struct {
  w           Mutex   // 互斥锁解决多个writer的竞争
  writerSem   uint32  // writer信号量
  readerSem   uint32  // reader信号量
  readerCount int32   // reader的数量
  readerWait  int32   // writer等待完成的reader的数量
}

const rwmutexMaxReaders = 1 << 30
```

通过记录 readerCount 读锁的数量来进行控制，这个readerCount有两个含义：

- 没有writer竞争或者持有锁的时候，readerCount就是当前reader的计数。
- 有writer竞争或者持有锁的时候，此时readerCount为负数，用来标识。

过程：

- 当一个reader释放（RUnlock）的时候，将readerCount减1。
- 当有一个writer获得锁之后，会将readerCount字段设为负数（相反数），此时readerCount既保存了reader的数量，又表示当前有writer持有锁。
- 当有writer进行抢占锁时，如果readerCount不为0，writer进入阻塞状态，直到所有活跃的reader都释放锁完毕，才会唤醒这个writer。
- 当一个writer释放锁（Unlock）的时候，会再次反转readerCount字段，唤醒之后新来阻塞的reader。

## 悲观锁与乐观锁

**Mutex是** **悲观锁**

### **悲观锁**

*当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发**。这种借助数据库锁机制，**在修改数据之前先锁定，再修改的方式被称之为悲观并发控制**【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。

### **乐观锁**

乐观锁是相对悲观锁而言的，**乐观锁假设数据一般情况不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果冲突，则返回给用户异常信息，让用户决定如何去做。乐观锁适用于读多写少的场景，这样可以提高程序的吞吐量**

## `sync.WaitGroup` 

### （1）用法

Go中的WaitGroup是一种常见的并发控制方式，一个 WaitGroup 对象可以等待一组goroutine结束。

一共有三个方法：

- `Add` 方法用于设置 WaitGroup 的计数值，可以理解为goroutine的数量
- `Done` 方法用于将 WaitGroup 的计数值减1，一个goroutine执行完后调用。
- `Wait` 方法用于阻塞调用者，直到 WaitGroup 的计数值为0，即所有goroutine都完成

### （2） 实现原理

```go
type WaitGroup struct {
    noCopy noCopy // noCopy 字段标识，由于 WaitGroup 不能复制，方便工具检测

    state1 [3]uint32  // 12个字节，8个字节标识 计数值和等待数量，4个字节用于标识信号量
}
```

-  WaitGroup 主要维护了一个复合字段state1，共12字节，分成了两个部分。第一部分前面8个字节标识 2 个计数器，一个是请求计数器 ，一个是等待计数器 ，二者组成一个 8字节 的值，请求计数器占高 4字节，等待计数器占低 4字节。第二部分 剩余 `32位`（4个字节）`semap` 用于标识信号量。
-  每次 Add 执行，请求计数器 加 1，Done 方法执行，等待计数器 1，请求计数器 为 0 时通过信号量唤醒 Wait()。

### （3）注意事项

- **保证 Add 在 Wait 前调用**
- **Add 中不传递负数**
- **任务完成后不要忘记调用 Done 方法，建议使用 defer wg.Done()**
- **不要复制使用 WaitGroup，函数传递时使用指针传递**
- **尽量不复用 WaigGroup，减少出问题的风险**

## `sync.Once`

**特性：`sync.Once` 可以确保在并发环境下某个操作只被执行一次，无论有多少 Goroutine 尝试执行它，是一个并发安全的操作。**

使用：`sync.Once` 主要通过 `Do` 方法来执行操作，该方法接收一个无参数无返回值函数作为参数，确保该函数只被执行一次。

```go
var once sync.Once
// 无参数无返回值的函数
func initialize() {
    // 初始化操作
}

func main() {
    once.Do(initialize) // 确保 initialize 函数只被执行一次
}
```

使用场景：

- **单例模式**：`sync.Once` 可以用于实现单例模式，确保某个对象只被初始化一次。
- **延迟初始化**：当需要在程序运行时执行某个初始化操作，并且只需要执行一次时，`sync.Once` 是一个很好的选择。
- **初始化资源**：在需要确保某个资源只被初始化一次的情况下，例如全局配置信息的加载等。

## 原子操作：`sync.atomic`

原子操作是指在多线程或并发编程中**不可被中断的操作，要么完全执行，要么完全不执行，不会被其他线程的操作所干扰。**原子操作通常是 CPU 提供的特性，可以保证在多线程并发执行的情况下，**对共享数据的操作是线程安全的。**

主要有以下特性：

- **不可分割性**：即要么完全执行，要么完全不执行，不可被中断。
- **并发安全**：原子操作能够保证在多线程并发的情况下，对共享数据的操作是线程安全的，不需要额外的同步机制（如锁）。
- **原子性**：原子操作是原子性的，不会出现竞争条件（race condition）。

Go中的 `sync/atomic` 包提供了原子操作。

## 原子操作和锁的区别

- **原子操作由底层硬件支持，而锁是基于原子操作+信号量完成的，由操作系统的调度器实现。若实现相同的功能，原子操作通常会更有效率，能利用计算机多核的优势。而锁的使用会引入额外的开销，可能会降低程序的性能。**
- **原子操作**适用于简单的操作，如对计数器的增减、标记位的设置等。**锁**适用于需要保证一系列操作的原子性，或者需要对共享资源进行复杂的操作和控制的场景。
- **原子操作不需要额外的同步机制（如锁）来保护共享资源，可以提高并发性能。**
- 原子操作是单个指令的互斥操作，互斥锁/读写锁是一种数据结构，可以完成临界区（多个指令)的互斥操作，扩大原子操作的范围，**锁保护的是一段逻辑。**
- **原子操作是无锁操作，属于乐观锁（假设操作值未曾被改编）；说起锁的时候，一般属于悲观锁（假设会有并发的操作想要修改被操作的值）。**

## sync.Pool 

**频繁地分配、回收内存会给 GC 带来一定的负担，`sync.Pool` 用于缓存临时对象，以便在需要时重用这些临时对象，从而减少内存分配GC的压力。`sync.Pool` 在高性能的并发编程中非常有用，特别是在需要频繁创建和销毁临时对象的场景下，比如说`对象池`的使用。**

主要有两个方法：

```go
Get()    // 从池中获取对象    obj := pool.Get().(string)
Put()    // 将对象放回池中    pool.Put(obj)
```

例子：

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	// 创建一个 sync.Pool 对象
	pool := sync.Pool{
		New: func() interface{} {
			// 当池中没有对象时，New 函数会被调用创建新对象
			fmt.Println("Creating a new object.")
			return new(int) // 返回一个新分配的 int 指针
		},
	}

	// 从 pool 中获取一个对象
	obj1 := pool.Get().(*int)
	fmt.Println("Get object 1:", *obj1)

	// 将对象放回 pool 中
	*obj1 = 100
	pool.Put(obj1)

	// 再次从 pool 中获取对象
	obj2 := pool.Get().(*int)
	fmt.Println("Get object 
}
```

