

# 常规DP

## [53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/description/)

![image-20240826232102205](https://s2.loli.net/2024/08/26/OxHk82lE6mZwi1T.png)

### **暴力搜索**

`````go
package main

import (
	"fmt"
	"math"
)

func Maxsub(nums []int) {
	maxNum := math.MinInt
	for i := 0; i < len(nums); i++ {
		sum := nums[i]
		for j := i + 1; j < len(nums); j++ {
			sum += nums[j]
			if sum > maxNum {
				maxNum = sum
			}
		}
	}
	fmt.Println(maxNum)
}

func main() {
	nums := []int{3, -4, 2, -1, 2, 6, -5, 4}
	Maxsub(nums)
}
`````

但是暴力的算法复杂度太高：$O(n^2)$

### **递推DP**

为了进一步改进，我们采用**动态规划**的方法来求解，首先将问题抽象成**最优子问题**，思路就是把所有的子数组进行分类，分解成数量较小的几个子问题，比如`[3, -4, 2, -1, 2, 6, -5, 4]`：

1. 第一类以 `3` 为结尾，即`[3]`，`max = 3`
2. 第二类以 `-4`结尾，即`[3.-4]、[-4]`，`max = -1`
3. 第三类以`2`结尾，即`[3,-4,2]、[-4.2]、[2]`，`max = 2`
4. 以此类推

如果我们能得到每一类子问题的最优解，通过比较就可以得到整个问题的最优解。

那么重叠子问题在哪呢？我们发现第三类子问题只是在第二类的基础上在每一个数组后面添加第三个数字，再增加一个第三个数字的数组。每一类子问题分成两种情况：

1. 继承前一类子数组得到的子数组，也就是`[3.-4]、[-4]`。此时，``max = 第二类子数组的最大值+第三个数字``。
2. 单独第三个数字的组成的子数组，也就是`[2]`。此时，``max=第三个数字``

**通俗来讲，这个问题就变成了，第`i`类子数组的最大值可以通过第`i-1`类的子数组的最大值和第`i`个数字获得，如果第`i-1`类子数组没法给第`i`类子数组 带来正增益，我们就抛弃前面的子数组，自己就是最大的子数组。**即：

- $if \quad max(i-1)>0, max(i) = max(i-1)+nums[i]$
- $if max(i-1)\leq 0,max(i) = nums[i]$

递推式：

- `sum[i] : 当前以 i 个元素结尾子序列的最大值`
- $sum[i] = max(sum[i-1]+nums[i],nums[i]),ans = max(sum[i],ans)$
- 初始化：`sum[0] = nums[0]`

当然这里`sum`可以不是数组，就变量即可。

代码：

`````go
func Maxsub(nums []int) {
    // nums := []int{3, -4, 2, -1, 2, 6, -5, 4}
	sum := 0
	ans := 0
	for i := 0; i < len(nums); i++ {
		sum = max(sum+nums[i], nums[i])
		ans = max(sum, ans)
	}
	fmt.Println(ans)
}

func Maxsub2(nums []int) {
    // nums := []int{3, -4, 2, -1, 2, 6, -5, 4}
	sum := make([]int, len(nums))
	sum[0] = nums[0]
	ans := nums[0]
	for i := 1; i < len(nums); i++ {
		sum[i] = max(sum[i-1]+nums[i], nums[i])
		ans = max(sum[i], ans)
	}
	fmt.Println(sum)	// [3 -1 2 1 3 9 4 8]
	fmt.Println(ans)	// 9
}
`````

## [509. 斐波那契数 - 力扣（LeetCode）](https://leetcode.cn/problems/fibonacci-number/description/)

### 动态规划

```go
func fib(n int) int {
	if n == 0 {
		return 0
	}
	f := make([]int, n+1)
	f[0], f[1] = 0, 1
	for i := 2; i <= n; i++ {
		f[i] = f[i-1] + f[i-2]
	}
	return f[n]
}
```

### 递归

`````go
func fib(n int)int{
	if n < 2{
		return n
	}
    return fib(n-1) +fib(n-2)
}
`````

## [70. 爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/climbing-stairs/description/)

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

### **分析**

我们先来递推下

`````go
n = 1 ：[1] = 1
n = 2 : [1+1 , 2] = 2
n = 3 : [1+2]，[1+1=1， 2+1] = 3
n = 4 : 2+1 ，3+1
可以看出，第三层，只需要通过第二层再走一步以及第一层的基础上再走两步得到
`````

所以得到

- `dp[i] : 走到第 i 层阶梯的方法数`
- `dp[i] = dp[i-1]+dp[i-2]，dp[i-1]为再走一步的方法，dp[i-2]为再走两步的方法`
- `dp[1] = 1 , dp[2] = 2 `

`````go
func climbStairs(n int) int {
	if n < 3 {
		return n
	}
	dp := make([]int, n+1)
	dp[1], dp[2] = 1, 2
	for i := 3; i <= n; i++ {
		dp[i] = dp[i-1] + dp[i-2]
	}
	return dp[n]
}
`````

## [57. 爬楼梯拓展 (kamacoder.com)](https://kamacoder.com/problempage.php?pid=1067)

题目描述

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 

每次你可以爬至多m (1 <= m < n)个台阶。你有多少种不同的方法可以爬到楼顶呢？ 

注意：给定 n 是一个正整数。

输入描述

输入共一行，包含两个正整数，分别表示n, m

输出描述

输出一个整数，表示爬到楼顶的方法数。

输入示例

```go
3 2
```

输出示例

```go
2
```

提示信息

当 m = 2，n = 3 时，n = 3 这表示一共有三个台阶，m = 2 代表你每次可以爬一个台阶或者两个台阶。

此时你有三种方法可以爬到楼顶。

代码：

`````go
package main

import "fmt"

func climbStairs(n, m int) int {
	dp := make([]int, n+1)
	dp[0], dp[1] = 1, 1
	for i := 2; i <= n; i++ {
		for j := 1; j <= m; j++ {
			if i-j >= 0 {
				dp[i] += dp[i-j]
			}
		}
	}
	return dp[n]
}

func main() {
	var n, m int
	fmt.Scan(&n, &m)
	fmt.Println(climbStairs(n, m))
}
`````

## [746. 使用最小花费爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/min-cost-climbing-stairs/description/)

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

**示例 1：**

```
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
```

**示例 2：**

```
输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。
```

- `dp[i]：到达第i台阶所花费的最少体力为dp[i]`
- `dp[i]` 递推，分两种情况，爬一步或者两步
  1. 爬一步：`dp[i] = dp[i-1] + const[i-1]`
  2. 爬两步：`dp[i] = dp[i-2] + const[i-2]`
  3. `dp[i] = min(dp[i-1] + const[i-1],dp[i-2] + const[i-2])`
- 初始化：`dp[0] = 0 , dp[1] = 0`，到达前面两个不花钱

```go
import "fmt"

func minCostClimbingStairs(cost []int) int {
	dp := make([]int, len(cost)+1)
	for i := 2; i <= len(cost); i++ {
		dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])
	}
	return dp[len(cost)]
}
func main() {
	cost := []int{10, 15, 20}
	fmt.Println(minCostClimbingStairs(cost))
}
```



# 背包问题
