# 思路

------

我怎么能想到用单调栈呢？ 什么时候用单调栈呢？

**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**。时间复杂度为O(n)。

那么单调栈的原理是什么呢？为什么时间复杂度是O(n)就可以找到每一个元素的右边第一个比它大的元素位置呢？

**单调栈的本质是空间换时间**，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。

在使用单调栈的时候首先要明确如下几点：

1. 单调栈里存放的元素是什么？

单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。

1. 单调栈里元素是递增呢？ 还是递减呢？

**注意以下讲解中，顺序的描述为 从栈顶到栈底的顺序**，因为单纯的说从左到右或者从前到后，不说栈头朝哪个方向的话，大家一定比较懵。

**这里我们要使用递增循序（再强调一下是指从栈顶到栈底的顺序），因为只有递增的时候，栈要加入一个元素i的时候，才知道栈顶元素在数组中右面第一个比栈顶元素大的元素是i。**

文字描述理解起来有点费劲，接下来我画了一系列的图，来讲解单调栈的工作过程。

使用单调栈主要有三个判断条件。

- 当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况
- 当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况
- 当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况

**把这三种情况分析清楚了，也就理解透彻了**。

**[496. 下一个更大元素 I - 力扣（LeetCode）](https://leetcode.cn/problems/next-greater-element-i/description/)**

**示例 1：**

```
输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
输出：[-1,3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。
- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
```

代码：

```go
func f(nums1, nums2 []int) []int {
	// 用一个单调栈找出num2中所有元素右边比自己大的第一个元素
	// 用map存储元素对应的关系
	// 遍历num1，寻找map的对应值
	st := make([]int, 0)
	mp := map[int]int{}
	for i := 0; i < len(nums2); i++ {
		// 大于，就保存结果，并出栈（持续）
		for len(st) > 0 && nums2[i] > nums2[st[len(st)-1]] {
			mp[nums2[st[len(st)-1]]] = nums2[i]
			st = st[:len(st)-1]
		}
		st = append(st, i) // 小于就入栈（单调增）
	}
	// 在map中找结果，没找到就为-1
	res := make([]int, len(nums1))
	for i, v := range nums1 {
		if _, ok := mp[v]; ok {
			res[i] = mp[v]
		} else {
			res[i] = -1
		}
	}
	return res
}
```

**[503. 下一个更大元素 II - 力扣（LeetCode）](https://leetcode.cn/problems/next-greater-element-ii/description/)**

**示例 1:**

```
输入: nums = [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
```

**示例 2:**

```
输入: nums = [1,2,3,4,3]
输出: [2,3,4,-1,4]
```

代码：

```go
func nextGreaterElements(nums1 []int) []int {
    // 单调栈+循环数组
	// 用一个单调栈找出num1中所有元素右边比自己大的第一个元素
	// 采用循环数组，扩大为2倍即可表示每个元素找两遍，然后下标取模
	st := make([]int, 0)
	res := make([]int, len(nums1))
	for i := range res {
		res[i] = -1
	}
	for i := 0; i < 2*len(nums1)-1; i++ {
		j := i % len(nums1)
		for len(st) > 0 && nums1[j] > nums1[st[len(st)-1]] {
			res[st[len(st)-1]] = nums1[j]
			st = st[:len(st)-1]
		}
		st = append(st, j)
	}
	return res
}
```

