# 字符串

---



## [LCR 020. 回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/a7VOhD/solutions/1021794/hui-wen-zi-zi-fu-chuan-de-ge-shu-by-leet-ejfv/)

### 方法一：中心拓展

思路与算法

计算有多少个回文子串的最朴素方法就是枚举出所有的回文子串，而枚举出所有的回文字串又有两种思路，分别是：

- 枚举出所有的子串，然后再判断这些子串是否是回文；

- **枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同的时候就拓展，否则停止拓展。**

假设字符串的长度为 n。我们可以看出前者会用 O(n^2) 的时间枚举出所有的子串，然后再用的时间检测当前的子串是否是回文，整个算法的时间复杂度是 O(n ^3)，而后者枚举回文中心的是 O(n) 的，对于每个回文中心拓展的次数也是 O(n) 的，所以时间复杂度是 O(n ^2)，所以我们选择第二种方法来枚举所有的回文子串。

在实现的时候，我们需要处理一个问题，**即如何有序地枚举所有可能的回文中心**，我们需要考虑回文长度是奇数和回文长度是偶数的两种情况。如果回文长度是奇数，那么回文中心是一个字符；如果回文长度是偶数，那么中心是两个字符。当然你可以做两次循环来分别枚举奇数长度和偶数长度的回文，但是我们也可以用一个循环搞定。我们不妨写一组出来观察观察，假设 n=4，我们可以把可能的回文中心列出来：

| 编号 `i`/ 回文长度奇偶 | 回文中心左起始位置 $l_i$ | 回文中心右起始位置 rl_i$ |
| ---------------------- | :----------------------- | :----------------------- |
| 0（偶）                | 0                        | 0                        |
| 1（奇）                | 0                        | 1                        |
| 2（偶）                | 1                        | 1                        |
| 3（奇）                | 1                        | 2                        |
| 4（偶）                | 2                        | 2                        |
| 5（奇）                | 2                        | 3                        |
| 6（偶）                | 3                        | 3                        |

由此我们可以看出长度为 n 的字符串会生成 2n−1 组回文中心$$[l_i,r_i]$$ 。其中： $$l_i=⌊i/2⌋，r_i=l_i+(i\text{mod}2)$$​，这样我们只要从 0 到 2n−2 遍历 i，就可以得到所有可能的回文中心，这样就把奇数长度和偶数长度两种情况统一起来了。

代码如下。

```go
func countSubstrings(s string) int {
    n := len(s)
    ans := 0
    for i := 0; i < 2 * n - 1; i++ {
        l, r := i / 2, i / 2 + i % 2
        for l >= 0 && r < n && s[l] == s[r] {
            l--
            r++
            ans++
        }
    }
    return ans
}
```

### 方法二：Manacher（马拉车）