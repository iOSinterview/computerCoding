# 2024年E卷100分题

[TOC]

# 流浪地球【标记逻辑】

![image-20240823171808980](https://s2.loli.net/2024/08/23/bTwYRoHNkzcQniO.png)

```go
package main

import (
	"fmt"
)

// 流浪地球
func f(N, E int, nums [][2]int) {
	// 定义一个数组flags，标记当前发动机的起动时间，初始设置为最晚时间N+1.
	// 初始化当前手动发动的时间
	// 遍历时间，然后遍历当前的flags，如果为当前时间发射的，将其标记为-1，表示发射了
	// 并将其没有发射的相邻的标记为下一时刻发射
	// 找出flags中最晚的（可能相等）
	flags := make([]int, N)
	for i := range flags {
		flags[i] = N + 1 // 给个最晚的初始值，有的发动机可能无法启动
	}
	// 设置手动发动机时间
	for _, num := range nums {
		flags[num[1]] = num[0]
	}
	// 遍历时间
	for i := 0; i <= N; i++ {
		for j, t := range flags {
			// t == i表示当前该启动，
			if t == i {
				flags[j] = -1 // 启动过的标记
				// 标记关联访问时间，（j-1+n）%n可以实现循环不越界
				if flags[(j-1+N)%N] != -1 && flags[(j+1+N)%N] != -1 {
					flags[(j-1+N)%N] = i + 1
					flags[(j+1+N)%N] = i + 1
				}
			}
		}
	}
	// 遍历flag，找出时间做大的（可能几个），记录索引
	maxT := -10
	res := make([]int, 0)
	for i, v := range flags {
		if v > maxT {
			maxT = v
			res = make([]int, 0) // 找到到更大的，清空之前大的集合
			res = append(res, i)
		} else if v == maxT {
			res = append(res, i)
		}
	}
	fmt.Println(len(res))
	fmt.Println(res)
}

func main() {
	var N, E int
	fmt.Scan(&N, &E)
	nums := make([][2]int, E)
	for i := 0; i < E; i++ {
		var T, P int
		fmt.Scan(&T, &P)
		nums[i][0] = T
		nums[i][1] = P
	}
	f(N, E, nums)
}
```

# 数大雁【模拟】

![image-20240823234122855](https://s2.loli.net/2024/08/23/hNJZmdHIjgMVDy8.png)

这里大眼可以连续叫，但是不能交替着叫。

用不同的颜色表示大雁，以下都是最少两只大雁。

<img src="https://s2.loli.net/2024/08/23/wjIAV1kDLJ6CF4y.png" alt="在这里插入图片描述"  style="float: left; margin-right: 10px;"/>

首先考虑返回`-1`的情况，即无法完成一只 大雁叫

- `'quack'`每个字符的次数如果不相等，则不能有完整的大雁叫。
- `'quack'`中如果前一个字符出现的次数小于当前字符次数。

考虑一个长度为`5`的` cnt`数组，用来计数`'quack'`中每个字符出现的次数，使用`map`存储字符与对应`cnt`的索引关系，接着考虑大雁是否可以复用。假设出现了一个新的`q`，表示出现了一声新的`quack`，分为如下情况

- 如果`cnt`中`'k'`字符的次数为0，则表示之前没有大雁完成了叫，或者完成了叫的大雁被复用，无需操作。
- 如果`cnt`中`'k'`的次数大于0，之前有某只大雁叫完了，当前大雁可以复用，对 `cnt`进行整体`-1`。

最后`cnt`中的数如果不相等，则不能有完整的大雁叫，相等，则值即为大雁的个数。

```go
package main

import (
	"fmt"
)

// 数大雁叫
func f(str string) int {
	mp := map[byte]int{'q': 0, 'u': 1, 'a': 2, 'c': 3, 'k': 4}
	var flagErr bool      // 异常标记
	cnt := make([]int, 5) // cnt统计每个字符出现的次数，最后的值应该相等才能有完整大雁
	for i := 0; i < len(str); i++ {
		idx, _ := mp[str[i]]
		cnt[idx] += 1
		// 当前不为‘q’，且前一个字符次数小于当前次数
		if str[i] != 'q' && cnt[idx-1] < cnt[idx] {
			flagErr = true
			break
		}
		if str[i] == 'q' && cnt[4] > 0 {
			// 存在大雁叫完过，这只大雁复用，整体计数值-1
			for j := range cnt {
				cnt[j] -= 1
			}
		}
	}

	// 返回-1的情况，cnt字符不相等，或者前面出现了异常
	if flagErr {
		return -1
	}
	cnteq := cnt[0]
	for i := range cnt {
		if cnteq != cnt[i] {
			return -1
		}
	}
	// cnt值相等，且值就为大雁的个数
	return cnt[0]
}

func main() {
	var str string
	fmt.Scan(&str)
	fmt.Println(f(str))
}
```

# 斗地主之顺子【哈希表+逻辑】

**题目描述：**

- 在斗地主扑克牌游戏中， 扑克牌由小到大的顺序为：3,4,5,6,7,8,9,10,J,Q,K,A,2，
- 玩家可以出的扑克牌阵型有：单张、对子、顺子、飞机、炸弹等。
- 其中顺子的出牌规则为：由 至少 5 张由小到大连续递增 的扑克牌组成，且 不能包含 2 。
- 例如：{3,4,5,6,7}、{3,4,5,6,7,8,9,10,J,Q,K,A}都是有效的顺子；
- 而{J,Q,K,A,2}、 {2,3,4,5,6}、{3,4,5,6}、{3,4,5,6,8}等都不是顺子。
- 给定一个包含13张牌的数组，如果有满足出牌规则的顺子，请输出顺子。
- 如果存在多个顺子，请每行输出一个顺子，且需要按顺子的 第一张牌的大小（必须从小到大） 依次输出。
- 如果没有满足出牌规则的顺子，请 输出 No 。

**输入描述:**

13张任意顺序的扑克牌，每张扑克牌数字用空格隔开，每张扑克牌的数字都是合法的，并且不包括大小王：

```
2 9 J 2 3 4 K A 7 9 A 5 6
```

不需要考虑输入为异常字符的情况

**输出描述:** 组成的顺子，每张扑克牌数字用空格隔开：

```
3 4 5 6 7
```

**示例1：**

**输入**

```
2 9 J 2 3 4 K A 7 9 A 5 6
```

**输出**

```
3 4 5 6 7
```

**说明**

13张牌中，可以组成的顺子只有1组：3 4 5 6 7

**示例2：**

**输入**

```
2 9 J 10 3 4 K A 7 Q A 5 6
```

**输出**

```
3 4 5 6 7
9 10 J Q K A
```

**说明**

13张牌中，可以组成2组顺子，从小到大分别为：3 4 5 6 7 和 9 10 J Q K A

**示例3：**

**输入**

```
2 9 9 9 3 4 K A 10 Q A 5 6
```

**输出**

```
No
```

**说明**

13张牌中，无法组成顺子

**注意：**

**特殊输入**

```
3 3 4 4 5 5 6 6 7 7 8 8 9
```

**对应输出**

```
3 4 5 6 7 8 9
3 4 5 6 7 8
```

**代码：**

`````go
// 斗地主之顺子
func main() {
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Scan()
	str := strings.Split(scanner.Text(), " ")
	nums := make([]int, 0)
	mp := map[string]int{
		"J": 11,
		"Q": 12,
		"K": 13,
		"A": 14,
	}
    // 将字符转为数字
	for _, v := range str {
		if _, ok := mp[v]; ok {
			nums = append(nums, mp[v])
		} else {
			x, _ := strconv.Atoi(v)
			if x != 2 { //  顺子只有3，4，5...J,Q,K,A
				nums = append(nums, x)
			}
		}
	}
	sort.Ints(nums)         //先排序
	res := make([][]int, 0) // 所有顺子
	ans := make([]int, 0)   // 一条顺子

	for len(nums) >= 5 { // 当前轮余下的顺子，顺子至少5张牌
		ans = append(ans, nums[0])
		nums = nums[1:]
		// 每轮找一对顺子
		for i := 0; i < len(nums); i++ {
			if nums[i] == ans[len(ans)-1] {
				continue // 相同的保留
			}
			if nums[i]-ans[len(ans)-1] == 1 { // 递增加入
				ans = append(ans, nums[i])
				// 删除加入的牌
				if i == len(nums)-1 {
					nums = nums[:i]
				} else {
					nums = append(nums[:i], nums[i+1:]...)
				}
				i-- // 删除了元素，下标要-1
			} else { // 不是递增，也不相等，断层
				if len(ans) >= 5 { // 当前是顺子
					res = append(res, ans) // 加入结果集
				}
				ans = make([]int, 0) // 断层清空当前顺子
				break                // 找下一对顺子
			}
		}
		// 一轮结束，如果还有顺子，也存起来
		if len(ans) >= 5 {
			res = append(res, ans)
		}
		ans = make([]int, 0)
	}
    // 开始转回来并输出
	mpitos := map[int]string{
		11: "J",
		12: "Q",
		13: "K",
		14: "A",
	}
	if len(res) == 0 {
		fmt.Printf("No")
	} else {
		for _, shunzi := range res {
			for i, v := range shunzi {
				var t string
				if v > 10 {
					t, _ = mpitos[v]
				} else {
					t = strconv.Itoa(v)
				}
				if i == len(shunzi)-1 {
					fmt.Print(t)
				} else {
					fmt.Printf("%s ", t)
				}
			}
			fmt.Println()
		}
	}
}
`````

其实也可以用一个`map[int]int`存储数字对应的次数，然后遍历map。

`````go
// 斗地主之顺子
func main() {
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Scan()
	str := strings.Split(scanner.Text(), " ")
	// nums := make([]int, 0)
	mpstoi := map[string]int{
		"J": 11,
		"Q": 12,
		"K": 13,
		"A": 14,
	}
	mp := map[int]int{}
	for _, v := range str {
		if x, ok := mpstoi[v]; ok {
			mp[x]++
		} else {
			x, _ := strconv.Atoi(v)
			if x != 2 { //  顺子只有3，4，5...J,Q,K,A
				mp[x]++
			}
		}
	}
	res := make([][]int, 0)
	flag := true		// 表示还能找得到顺子
	// fyes := false
	for flag {
		flag = false
		for i := 3; i < 11; i++ {
			// 存在数字 3~10，只有以这些开头才能是顺子
			if _, ok := mp[i]; !ok {
				continue
			}
			ans := []int{}
			for j := 0; j < 15; j++ {
				if _, ok := mp[i+j]; ok {
					ans = append(ans, i+j)
					mp[i+j]--
					if mp[i+j] == 0 {
						delete(mp, i+j)
					}
				} else {
					// 当前i找不到递增的，结束
					break
				}
			}
			if len(ans) >= 5 {
				sort.Ints(ans)
				res = append(res, ans)
				flag = true
				i = i + len(ans) - 1
			}
		}
	}
	mpitos := map[int]string{
		11: "J",
		12: "Q",
		13: "K",
		14: "A",
	}
	if len(res) == 0 {
		fmt.Printf("No")
	} else {
		for _, shunzi := range res {
			for i, v := range shunzi {
				var t string
				if v > 10 {
					t, _ = mpitos[v]
				} else {
					t = strconv.Itoa(v)
				}
				if i == len(shunzi)-1 {
					fmt.Print(t)
				} else {
					fmt.Printf("%s ", t)
				}
			}
			fmt.Println()
		}
	}
}
`````

# boss的收入【DFS+Map】

`````
一个XX产品行销总公司，只有一个 boss，其有若干一级分销，一级分销又有若干二级分销，每个分销只有唯一的上级分销。规定每个月，下级分销需要将自己的总收入(自己的+下级上交的)每满100元上交15元给自己的上级.现给出一组分销的关系，和每个分销的收入，请找出 boss并计算出这 boss 的收入。比如:收入100元上交15元,收入199元(9元不够100)上交15元，收入200元，上交30元。
分销关系和收入:分销id 上级分销的ld 收入
分销ID范围0…65535
收入范围:0…65535,单位元
提示: 输入的数据只存在1个 boss，不存在环路
输入描述
第1行输入关系的总数量N
第2行开始，输入关系信息，格式:分销ID 上级分销ID 收入
输出描述
boss的ID 总收入
补充说明
给定的输入数据都是合法的，不存在重复
示例1
输入
5
1 0 100
2 0 200
3 0 300
4 0 200
5 0 200
输出
0 150
示例2:
输入
3
1 0 223
2 0 323
3 2 1203
输出
0 105
说明
2的最终收入等于323+1203/100*15=323+180
0的最终收入等于(323+180+ 223)/100*15=105
`````

**代码**

`````go
package main

import "fmt"

func BossMoney(info [][]int) {
	n := len(info)
	// 创建两个map
	inMap := map[int]int{}   // key:subid , val:money
	reMap := map[int][]int{} // key:subid，val:下级subid集合
	for i := 0; i < n; i++ {
		if _, ok := inMap[info[i][0]]; !ok {
			inMap[info[i][0]] = info[i][2]
		}
		reMap[info[i][1]] = append(reMap[info[i][1]], info[i][0])
	}
	// 寻找boossubid，bossid不在inMap中
	bossid := 0
	for subid, _ := range reMap {
		if _, ok := inMap[subid]; !ok {
			bossid = subid
			break
		}
	}
	inMap[bossid] = 0
	// 深度遍历bossid的内一个下属的收入
	bossMoney := 0
	var dfs func(parentid int) int
	dfs = func(parentid int) int {
		// 终止条件，不在reMap中，没有下一级，返回当前收入
		if _, ok := reMap[parentid]; !ok {
			return inMap[parentid]
		}
		// 当前层收入 += 接收下一层的收入
		for _, subid := range reMap[parentid] {
			inMap[parentid] += dfs(subid) / 100 * 15
		}
		// 全部遍历完，返回最终的收入
		return inMap[parentid]
	}
	bossMoney = dfs(bossid)
	fmt.Println(bossid, bossMoney)
}

func main() {
	var n int
	fmt.Scan(&n)
	Info := make([][]int, n)
	for i := 0; i < n; i++ {
		Info[i] = make([]int, 3)
		fmt.Scan(&Info[i][0], &Info[i][1], &Info[i][2])
	}
	fmt.Println(Info)
	BossMoney(Info)
}
`````

# 贪心的商人/最大利润【DP/贪心】

**题目描述**
商人经营一家店铺，有`number`种商品，由于仓库限制每件商品的最大持有数量是`item[index]`,每种商品的价格在每天是`item _price[item_index]`，通过对商品的买进和卖出获取利润，请给出商人在`days`天内能获取到的最大的利润，

 注：同一件商品可以反复买进和卖出： 

**输入描述** 

`````
3 //输入商品的数量number 
3 //输入商人售货天数days 
4 5 6   //输入仓库限制每件商品的最大持有数量是item[index]
1 2 3   //输入第一件商品每天的价格
4 3 2   //输入第二件商品每天的价格
1 5 3   //输入第三件商品每天的价格
`````

**输出描述**

```32
32     //输出商人在这段时间内的最大利润
```

分析，这是买卖股票的最佳时机的改编题，可用「DP」或者「贪心」解题。

- `dp[i]：当前天卖出的利润`
- `dp[i] = max(days[x][i] - days[x][i-1],0)`
- `dp[0] = 0`
- 然后累加`dp`得到商品`x`的利润，实际的时候既然利润要累加，用变量即可 
- 最后得到总商品的利润

```
比如
[1,3,5,2,7,4]
dp[]
[0,2,2,0,2,0]
```

**代码**

```go
package main

import "fmt"

func f(item []int, days [][]int) int {
	sum := 0
	// 模拟遍历每一件商品，再遍历天数
	for i, x := range item {
		r := 0
		for j := 1; j < len(days[0]); j++ {
			v := days[i][j] - days[i][j-1]
			if v > 0 {
				r += v
			}
		}
		sum += x * r
	}
	return sum
}

func main() {
	var n, d int
	fmt.Scan(&n, &d)
	item := make([]int, n)
	for i := 0; i < n; i++ {
		fmt.Scan(&item[i])
	}
	days := make([][]int, n)
	for i := range days {
		days[i] = make([]int, d)
		for j := range days[i] {
			fmt.Scan(&days[i][j])
		}
	}
	fmt.Println(item)
	fmt.Println(days)
	fmt.Println(f(item, days))
}
```



