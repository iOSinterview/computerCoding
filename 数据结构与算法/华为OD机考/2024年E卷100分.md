# 2024年E卷100分题

[TOC]

# 流浪地球【标记逻辑】

![image-20240823171808980](https://s2.loli.net/2024/08/23/bTwYRoHNkzcQniO.png)

```go
package main

import (
	"fmt"
)

// 流浪地球
func f(N, E int, nums [][2]int) {
	// 定义一个数组flags，标记当前发动机的起动时间，初始设置为最晚时间N+1.
	// 初始化当前手动发动的时间
	// 遍历时间，然后遍历当前的flags，如果为当前时间发射的，将其标记为-1，表示发射了
	// 并将其没有发射的相邻的标记为下一时刻发射
	// 找出flags中最晚的（可能相等）
	flags := make([]int, N)
	for i := range flags {
		flags[i] = N + 1 // 给个最晚的初始值，有的发动机可能无法启动
	}
	// 设置手动发动机时间
	for _, num := range nums {
		flags[num[1]] = num[0]
	}
	// 遍历时间
	for i := 0; i <= N; i++ {
		for j, t := range flags {
			// t == i表示当前该启动，
			if t == i {
				flags[j] = -1 // 启动过的标记
				// 标记关联访问时间，（j-1+n）%n可以实现循环不越界
				if flags[(j-1+N)%N] != -1 && flags[(j+1+N)%N] != -1 {
					flags[(j-1+N)%N] = i + 1
					flags[(j+1+N)%N] = i + 1
				}
			}
		}
	}
	// 遍历flag，找出时间做大的（可能几个），记录索引
	maxT := -10
	res := make([]int, 0)
	for i, v := range flags {
		if v > maxT {
			maxT = v
			res = make([]int, 0) // 找到到更大的，清空之前大的集合
			res = append(res, i)
		} else if v == maxT {
			res = append(res, i)
		}
	}
	fmt.Println(len(res))
	fmt.Println(res)
}

func main() {
	var N, E int
	fmt.Scan(&N, &E)
	nums := make([][2]int, E)
	for i := 0; i < E; i++ {
		var T, P int
		fmt.Scan(&T, &P)
		nums[i][0] = T
		nums[i][1] = P
	}
	f(N, E, nums)
}
```

# 数大雁【模拟】

![image-20240823234122855](https://s2.loli.net/2024/08/23/hNJZmdHIjgMVDy8.png)

这里大眼可以连续叫，但是不能交替着叫。

用不同的颜色表示大雁，以下都是最少两只大雁。

<img src="https://s2.loli.net/2024/08/23/wjIAV1kDLJ6CF4y.png" alt="在这里插入图片描述"  style="float: left; margin-right: 10px;"/>

首先考虑返回`-1`的情况，即无法完成一只 大雁叫

- `'quack'`每个字符的次数如果不相等，则不能有完整的大雁叫。
- `'quack'`中如果前一个字符出现的次数小于当前字符次数。

考虑一个长度为`5`的` cnt`数组，用来计数`'quack'`中每个字符出现的次数，使用`map`存储字符与对应`cnt`的索引关系，接着考虑大雁是否可以复用。假设出现了一个新的`q`，表示出现了一声新的`quack`，分为如下情况

- 如果`cnt`中`'k'`字符的次数为0，则表示之前没有大雁完成了叫，或者完成了叫的大雁被复用，无需操作。
- 如果`cnt`中`'k'`的次数大于0，之前有某只大雁叫完了，当前大雁可以复用，对 `cnt`进行整体`-1`。

最后`cnt`中的数如果不相等，则不能有完整的大雁叫，相等，则值即为大雁的个数。

```go
package main

import (
	"fmt"
)

// 数大雁叫
func f(str string) int {
	mp := map[byte]int{'q': 0, 'u': 1, 'a': 2, 'c': 3, 'k': 4}
	var flagErr bool      // 异常标记
	cnt := make([]int, 5) // cnt统计每个字符出现的次数，最后的值应该相等才能有完整大雁
	for i := 0; i < len(str); i++ {
		idx, _ := mp[str[i]]
		cnt[idx] += 1
		// 当前不为‘q’，且前一个字符次数小于当前次数
		if str[i] != 'q' && cnt[idx-1] < cnt[idx] {
			flagErr = true
			break
		}
		if str[i] == 'q' && cnt[4] > 0 {
			// 存在大雁叫完过，这只大雁复用，整体计数值-1
			for j := range cnt {
				cnt[j] -= 1
			}
		}
	}

	// 返回-1的情况，cnt字符不相等，或者前面出现了异常
	if flagErr {
		return -1
	}
	cnteq := cnt[0]
	for i := range cnt {
		if cnteq != cnt[i] {
			return -1
		}
	}
	// cnt值相等，且值就为大雁的个数
	return cnt[0]
}

func main() {
	var str string
	fmt.Scan(&str)
	fmt.Println(f(str))
}
```

