

# C/D卷100分题

# 1、字符串序列判定/最后一个有效字符（双指针）

```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func SubStr(S, L string) int {
	res := -1
	// i,j分别指向S，L；在L中招S中的元素，
	// 找到则继续S下一个，没找到则返回-1，
	// 直到S遍历完，返回最后L的下标
	var j int
	for i := 0; i < len(S); i++ {
		// 不等于继续往下走
		for j < len(L) && S[i] != L[j] {
			j++
		}
		// 等于，如果L已经遍历完，但是S还没有，则不存在
		if j >= len(L) && i < len(S)-1 {
			res = -1
			break
		}
		// 更新当前最后子串下标
		res = j
	}
	return res
}

func main() {
	reader := bufio.NewScanner(os.Stdin)
	// reader.Scan() 函数尝试读取输入并返回一个布尔值
	reader.Scan()
	S := reader.Text() // 读取内容
	reader.Scan()
	L := reader.Text()
	fmt.Print(SubStr(S, L))
}
```

# 2、统计山脉个数（逻辑，上升子序列）

```go
package main

import (
	"bufio"
	"fmt"
	"math"
	"os"
	"strconv"
	"strings"
)

// 统计山脉个数
func countMountains(num []int) int {
	var res int
	// 统计边界
	L := len(num)
	if L == 1 {
		return 1
	}
	if L > 1 {
		if num[0] > num[1] {
			res += 1
		}
		if num[L-1] > num[L-2] {
			res += 1
		}
	}
	// 统计中间
	for i := 1; i < len(num)-1; i++ {
		if num[i] > num[i-1] && num[i] > num[i+1] {
			res += 1
		}
	}
	return res
}

// 进阶版
func countMountains2(num []int) (res int) {
	// 转化为找升序或者降序子序列个数，开头或者结尾即为山峰的位置
	pre := math.MinInt
	isUp := true // 判断是否为峰
	for _, v := range num {
		if v > pre {
			pre = v
			isUp = true
			continue // 上升就继续找，不进行后面的逻辑判断
		}
		// 此时 v <= pre，且前面为上升
		if isUp {
			res++
			isUp = false
		}
		pre = v // pre跟上
	}
	return
}

func main() {
	reader := bufio.NewScanner(os.Stdin)
	reader.Scan()
	str := reader.Text()
	m := strings.Split(str, ",")
	// 转为整数
	var num []int
	for i := range m {
		x, _ := strconv.Atoi(m[i])
		num = append(num, x)
	}
	fmt.Println(countMountains2(num))
}
```

# 3、构成指定长度字符串的个数（回溯）

```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
	"unicode"
)

// 构成指定长度字符串的个数

func main() {
	reader := bufio.NewScanner(os.Stdin)
	reader.Scan()
	str := reader.Text()
	ss := strings.Split(str, " ")
	s := ss[0]
	n, _ := strconv.Atoi(ss[1])

	mp := map[rune]int{} // 统计字符出现的次数
	// unicode.IsLetter(c)检查是否为字母
	for _, c := range s {
		if !unicode.IsLetter(c) {
			fmt.Println(0)
			return
		}
		fmt.Printf("%T,", c)
		mp[c]++
	}
	var res int
	// 回溯函数，接收当前长度积上个遍历字符
	var dfs func(cnt int, pre rune)
	dfs = func(cnt int, pre rune) {
		// 终止条件
		if cnt == n {
			res++
			return
		}
		// 循环
		for k, v := range mp {
			// 当前元素被使用或者相邻重复，下一轮（下个元素）
			if v == 0 || k == pre {
				continue
			}
			//当前层处理
			mp[k]--
			// 递归
			dfs(cnt+1, k)
			mp[k]++
		}
	}

	var pre rune
	dfs(0, pre)
	fmt.Println(res)
}
```

# 4、用连续自然数之和来表达整数（逻辑）

```go
package main

import (
	"fmt"
)

// 连续自然数之和来表示整数
func sumNum(tar int) [][]int {
	// 先将目标函数接入结果集
	res := [][]int{{}}
	res[0] = []int{tar}

	// 遍历小于目标值的自然数
	// 从当前的自然数出发，每次增加1，用目标函数每次-当前自然数
	// 如果>0，先加入 缓冲区tmp
	// 直到<=0，如果等于0，则找到了，直接加入结果集
	for i := 1; i < tar; i++ {
		N := tar
		var tmp []int
		v := i
		for N-v > 0 {
			tmp = append(tmp, v)
			N -= v
			v++
		}
		if N-v == 0 {
			tmp = append(tmp, v)
			res = append(res, tmp)
			continue
		}
	}
	return res
}

func main() {

	var tar int
	fmt.Scan(&tar)
	res := sumNum(tar)
	for i := 0; i < len(res); i++ {
		fmt.Printf("%d=", tar)
		for j := 0; j < len(res[i]); j++ {
			if j < len(res[i])-1 {
				fmt.Printf("%d+", res[i][j])
            }
		}
		fmt.Printf("\n")
	}
	fmt.Printf("Result:%d", len(res))
}
```

# 5、全量字符集和已占用字符集

```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

// 全量字符集和以后再那用字符集
func usedChar(totalStr, usedStr []string) {
	mp := map[byte]int{}
	// 用map统计占用频次，等下全量频次好按顺序
	for _, s := range usedStr {
		x, _ := strconv.Atoi(s[2:]) // 可能>10
		mp[s[0]] = x
	}

	for i, s1 := range totalStr {
		if q, ok := mp[s1[0]]; ok {
			// 存在，则减少
			x, _ := strconv.Atoi(s1[2:])
			if x > q {
				fmt.Printf("%c:%d", s1[0], x-q)
				if i < len(totalStr)-1 {
					fmt.Printf(",")
				}
			}
		} else {
			// 不存在，直接输出
			fmt.Printf("%s", s1)
			if i < len(totalStr)-1 {
				fmt.Printf(",")
			}
		}
	}
}

func main() {
	reader := bufio.NewScanner(os.Stdin)
	reader.Scan()

	str := strings.Split(reader.Text(), "@")
	totalStr := strings.Split(str[0], ",")
	usedStr := strings.Split(str[1], ",")

	usedChar(totalStr, usedStr)
}
```

# 6、密码正确检测（字符串逻辑）

```go
package main

import (
	"fmt"
	"unicode"
)

// 密码正确检测
func chekPassword(inStr string) {
	passwd := []rune{}
	var Upper, Lower, Num, ex bool

	for _, ch := range inStr {
		// < 字符处理
		if ch == '<' {
			if len(inStr) > 0 {
				passwd = passwd[:len(passwd)-1] // 删除最后一个元素
			}
			continue
		}
		// 至少有一个大写字母，即Upper至少一次为true就行
		if Upper || unicode.IsUpper(ch) {
			Upper = true
		}
		if Lower || unicode.IsLower(ch) {
			Lower = true
		}
		if Num || unicode.IsNumber(ch) {
			Num = true
		}
		// 特殊字符：非字母、数字、空白
		if ex || (!unicode.IsLetter(ch) && !unicode.IsNumber(ch) && unicode.IsSpace(ch)) {
			ex = true
		}
		passwd = append(passwd, ch)
	}
	fmt.Printf("%s,", string(passwd))
	if len(passwd) >= 8 && Upper && Lower && Num && ex {
		fmt.Printf("true")
	} else {
		fmt.Printf("false")
	}
}

func main() {
	var inStr string
	fmt.Scan(&inStr)

	chekPassword(inStr)
}
```

# 7、众数与中位数（逻辑）

```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"sort"
	"strconv"
	"strings"
)

// 众数与中位数
// 10 11 21 19 21 17 21 16 21 18 15
// 21
// 2 1 5 4 3 3 9 2 7 4 6 2 1 5 4 2 4
// 3
// 5 1 5 3 5 2 5 5 7 6 7 3 7 11 7 55 7 9 98 9 17 9 15 9 9 1 39
// 7

func main() {
	reader := bufio.NewScanner(os.Stdin)
	reader.Scan()
	s := reader.Text()
	str := strings.Split(s, " ")
	mp := map[int]int{}
	maxcnt := 0 // 记录最多频次的
	for _, ch := range str {
		x, _ := strconv.Atoi(string(ch))
		mp[x] += 1
		if mp[x] > maxcnt {
			maxcnt = mp[x]
		}
	}

	nums := []int{}
	for k, v := range mp {
		// 将频次最大的数加入
		if v == maxcnt {
			nums = append(nums, k)
		}
	}

	sort.Ints(nums)
	n := len(nums)
	if n%2 == 0 {
		res := (nums[n/2-1] + nums[n/2]) / 2
		fmt.Println(res)
	} else {
		fmt.Println(nums[n/2])
	}
}
```

# 8、最长的指定瑕疵度的元音子串（双指针）

```go
package main

import (
	"fmt"
)

// 最长的指定瑕疵度的元音子串：元音：a、i、e、o、u、
// asdbuiodevauufgh 3
func main() {
	var flow int
	fmt.Scanln(&flow)
	var s string
	fmt.Scanln(&s)
	mp := map[byte]bool{'a': true, 'A': true, 'i': true, 'I': true,
		'e': true, 'E': true, 'o': true, 'O': true, 'u': true, 'U': true}
	// 双指针
	// 准备一个元音字符串字典
	// R判断当前是否为元音，不是，cnt++；不是或者没超过瑕疵，继续往后
    // 是元音，且瑕疵刚好flow==cnt，开始移动l
	// cnt>flow 或者 l不是元音，l++；如果l不是元音，cnt--；
    // 如果l>r，则l=r，且几位数移动l，开始移动尾巴
	// l是元音且cnt==flow，则记录
	var res int
	l := 0
	cnt := 0
	for r := 0; r < len(s); r++ {
		if !mp[s[r]] {
			cnt++
		}
		// 尾巴不是元音，但是瑕疵还够，继续往后走
		if !mp[s[r]] || cnt < flow {
			continue
		}
		// 尾巴是元音，对头部进行判断，达到最大瑕疵且头部是元音
		if cnt == flow && mp[s[l]] {
			res = max(res, r-l+1)
		}
		// 超过瑕疵，头部且不为元音，需要头部后移动
		for cnt > flow || !mp[s[l]] {
			l++
			if !mp[s[l]] {
				cnt--
			}
			if l > r {
				l = r // 移动过r，结束移动头，开始移动尾巴
				break
			}
		}
		if cnt == flow && mp[s[l]] {
			res = max(res, r-l+1)
		}
	}
	fmt.Println(res)
}
```

# 9、整数对最小和（最小堆）

```go
package main

import (
	"container/heap"
	"fmt"
	"sort"
)

type compose struct {
	idx1, idx2 int // 保存元素下标
	sum        int
}

// 定义一个整数切片，实现heap.Interface 接口方法
type cHeap []compose

func (h cHeap) Len() int           { return len(h) }
func (h cHeap) Less(i, j int) bool { return h[i].sum < h[j].sum }
func (h cHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *cHeap) Push(x interface{}) {
	*h = append(*h, x.(compose))
}

func (h *cHeap) Pop() interface{} {
	old := *h
	n := len(old)
	x := old[n-1]
	*h = old[:n-1]
	return x
}

// 整数对最小和
func minNum(arr1, arr2 []int, k int) (res int) {
	// 最小堆初始化
	h := &cHeap{}
	heap.Init(h)
	// 将arr1每个元素跟arr2第一个元素相加
	for i, v := range arr1 {
		heap.Push(h, compose{i, 0, v + arr2[0]})
	}
	for k > 0 {
		p := heap.Pop(h).(compose) // 弹出最小
		t1, t2, num := p.idx1, p.idx2, p.sum
		res += num
		k--
		// 每次将arr2的下个元素跟当前弹出arr1下标的元素加入heap
		if t2+1 < len(arr2) {
			heap.Push(h, compose{t1, t2 + 1, arr1[t1] + arr2[t2+1]})
		}
	}
	return res
}

func main() {
	var n1, n2 int
	fmt.Scan(&n1)
	arr1 := make([]int, n1)
	for i := range arr1 {
		fmt.Scan(&arr1[i])
	}
	fmt.Scan(&n2)
	arr2 := make([]int, n2)
	for i := range arr2 {
		fmt.Scan(&arr2[i])
	}
	var k int
	fmt.Scan(&k)
	sort.Ints(arr1)
	sort.Ints(arr2)
	fmt.Println(minNum(arr1, arr2, k))
}
```

# 10、找出作弊的人（排序比较）

```go
package main

import (
	"fmt"
	"sort"
)

// 找出作弊的人
func Findman(score [][2]int, n int) (res [][2]int) {
	// 给成绩切片按成绩排序
	sort.Slice(score, func(i, j int) bool {
		return score[i][1] < score[j][1]
	})
	minNum := 300 // 当前的最小分差
	for i := 1; i < n; i++ {
		// 每次看相邻的分差，有序后相邻的分差最小
		pid, pfs := score[i-1][0], score[i-1][1]
		cid, cfs := score[i][0], score[i][1]
		// ID有序
		if cid < pid {
			pid, cid = cid, pid
		}
		// 分差<minNum，则代表有更小的，更新；分差==minNum,添加即可
		if cfs-pfs < minNum {
			minNum = cfs - pfs
			res = [][2]int{[2]int{pid, cid}}
		} else if cfs-pfs == minNum {
			res = append(res, [2]int{pid, cid})
		}
	}
	// 按ID排序
	sort.Slice(res, func(i, j int) bool {
		return res[i][0] < res[j][0]
	})
	return res
}

func main() {
	var n int
	fmt.Scan(&n)
	score := make([][2]int, n)
	for i := 0; i < n; i++ {
		fmt.Scan(&score[i][0], &score[i][1])
	}
	res := Findman(score, n)
	for _, v := range res {
		fmt.Printf("%d %d\n", v[0], v[1])
	}
}
```

# 11、环中最长子串/字符成环找偶数O（逻辑/滑动窗口）

```go
package main

import (
	"fmt"
)

func f1(str string) int {
	// 1、统计str中o的个数
	// 2、为偶数返回整体长度，为奇数返回n-1
	var cnt, n int
	for _, ch := range str {
		n++
		if ch == 'o' {
			cnt++
		}
	}
	if cnt%2 == 0 {
		return n
	} else {
		return n - 1
	}
}

func main() {
	var str string
	fmt.Scan(&str)
	fmt.Println(f1(str))
}
```

# 12、找座位（逻辑）

```go
package main

import (
	"fmt"
)

func f1(s string) int {
	cnt := 0
	n := len(s)
	for i, ch := range s {
		// 头判断
		if i == 0 && i+1 < n && s[i+1] == '1' {
			continue
		}
		// 1判断
		if ch == '1' {
			continue
		}
		// 尾巴判断
		if i == n-1 && i-1 >= 0 && s[i-1] == '1' {
			continue
		}
		// 到这只能是中间且当前s[i]=='0'
		if s[i-1] == '1' || s[i+1] == '1' {
			continue
		}
		cnt++
	}
	return cnt
}

func main() {
	var str string
	fmt.Scan(&str)
	fmt.Println(f1(str))
}
```

# 13、转盘寿司（暴力逻辑/单调栈）

```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

// 转盘寿司
func f1(a []int) {
	// 1、访问每个元素
	// 2、从当前元素的右边找，在如果下一个j小于当前i，则加上j
	// 3、没有找到则从左边找，
	b := make([]int, len(a))
	copy(b, a)
	for i := 0; i < len(a); i++ {
		// 从右边找
		find := false
		for j := i + 1; j < len(a); j++ {
			if a[j] < a[i] {
				b[i] += a[j]
				find = true
				break
			}
		}
		// 从左边找
		if find == false {
			for j := 0; j < i; j++ {
				if a[j] < a[i] {
					b[i] += a[j]
					break
				}
			}
		}
	}
	for i, v := range b {
		fmt.Print(v)
		if i < len(b)-1 {
			fmt.Print(" ")
		}
	}
}

func main() {
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Scan()
	s := strings.Split(scanner.Text(), " ")
	a := make([]int, len(s))
	for i, v := range s {
		a[i], _ = strconv.Atoi(v)
	}
	f1(a)
}
```

# 14、找朋友（单调栈）

```go
package main

import (
	"fmt"
)

// 找朋友
func f(height []int, N int) {
	// 如果当前元素小于栈顶，则入栈（没找到朋友入栈）
	// 如果栈不为空，且当前元素大于栈顶元素，则出栈。（找到朋友出栈）
	res := make([]int, N)
	st := []int{0} // 初始将第一个元素入栈
	for i, v := range height[1:] {
		for len(st) > 0 && v > height[st[len(st)-1]] {
			x := st[len(st)-1]
			st = st[:len(st)-1] // 出栈
			res[x] = i + 1      // 将当前朋友加入
		}
		// 没有找到朋友，入栈
		st = append(st, i+1)
	}
	for _, v := range res {
		fmt.Printf("%d ", v)
	}
}

func main() {
	var n int
	fmt.Scan(&n)
	height := make([]int, n)
	for i := 0; i < n; i++ {
		fmt.Scan(&height[i])
	}
	f(height, n)
}
```

# 15、爱吃蟠桃的孙悟空（二分查找）

```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"sort"
	"strconv"
	"strings"
)

// 爱吃蟠桃的孙悟空
func f(tao []int, h int) int {
	// 一个小时只能吃一棵树桃子，即h<len(tao)，肯定吃不完
	// h>= len(tao)，可以吃完，找最小的速度
	// 二分查找，sort.Search(n,func(i int)bool{return })
	// 花费时间：tao/i向上取整。(tao+i-1)/i，h减去花费时间，如果小于0，则不能
	n := len(tao)
	if h < n {
		return 0
	}
	k := sort.Search(int(1e9), func(i int) bool {
		return check(tao, h, i)
	})
	return k
}

func check(tao []int, h int, k int) bool {
	for _, v := range tao {
		h -= (v + (k - 1)) / k // v/k向上取整
		if h < 0 {
			return false
		}
	}
	return true
}

func main() {
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Scan()
	str := strings.Split(scanner.Text(), " ")
	tao := make([]int, len(str))
	for i, v := range str {
		tao[i], _ = strconv.Atoi(v)
	}
	var h int
	fmt.Scan(&h)
	fmt.Println(f(tao, h))
}
```

# 16、游戏分组（DFS，DP）

```go
package main

import (
	"fmt"
)

// 游戏分组（类似石头碰撞，可以用dp）
func main() {
	nums := make([]int, 10)
	sum := 0
	for i := range nums {
		fmt.Scan(&nums[i])
		sum += nums[i]
	}

	// 分两组，每组5人（树深为5），，
	// 计算当前分组分值之间差的绝对值的最小值
	res := sum
	// start：开始元素；cur：当前分值；cnt：当前层数
	var dfs func(start int, cur int, cnt int)
	dfs = func(start int, cur int, cnt int) {
		// 终止条件
		if cnt == 5 {
			res = min(res, abs(cur-(sum-cur)))
			return
		}
		// 循环
		for i := start; i < len(nums); i++ {
			// 跳过
			// 递归
			dfs(start+1, cur+nums[i], cnt+1)
		}
	}
	dfs(0, 0, 0)
	fmt.Println(res)
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}
```

# 59、小华地图寻宝（DFS）

```go
package main

import (
	"fmt"
)

// 小华地图寻宝
func main() {
	var m, n, k int
	fmt.Scan(&m, &n, &k)
	visit := make([][]int, m) // 标记格子是否被访问过
	for i := range visit {
		visit[i] = make([]int, n)
	}

	var cur int // 黄金
	var dfs func(x, y int)
	dfs = func(x, y int) {
		// 终止条件：越界、被访问过、有危险
		if x >= m || x < 0 || y >= n || y < 0 {
			return
		}
		sum := 0 // 当前位数之和
		sum = x/10 + x%10 + y/10 + y%10
		if visit[x][y] == 1 || sum > k {
			return
		}
		visit[x][y] = 1
		cur++
		// 递归，左右上下
		dfs(x+1, y)
		dfs(x-1, y)
		dfs(x, y+1)
		dfs(x, y-1)

	}

	dfs(0, 0)
	fmt.Println(cur)
}
```

# 68、核酸检测（DFS）

```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

// 核算检测
func check(n int, org []int, grid [][]int) int {
	// 初始化一个n的visit数组，表示是否已经确定需要核酸
	visit := make([]int, n)

	// 对每个确诊病例进行dfs
	// dfs中，将当前节点标记为已访问
	// 然后遍历当前节点的所有邻接节点，如果邻接节点未被访问，递归对邻接节点执行dfs
	var dfs func(cur int)
	dfs = func(cur int) {
		// 终止条件，访问过（统计过）即返回
		if visit[cur] == 1 {
			return
		}

		// 将当前节点标记为访问，有接触，需要核酸
		visit[cur] = 1

		// 遍历当前节点的邻接节点，循环
		for i := 0; i < n; i++ {
			// 找邻接节点
			if grid[cur][i] == 1 && i != cur {
				dfs(i)
			}
		}
	}
	// 对每个病例进行dfs
	for _, v := range org {
		dfs(v)
	}
	// 统计结果，排除病原体的
	res := 0
	for _, v := range visit {
		if v == 1 {
			res += 1
		}
	}
	res = res - len(org)
	return res
}

func main() {

	reader := bufio.NewScanner(os.Stdin)
	reader.Scan()
	n, _ := strconv.Atoi(reader.Text())

	reader.Scan()
	s1 := strings.Split(reader.Text(), ",")
	var org []int
	for i := 0; i < len(s1); i++ {
		num, _ := strconv.Atoi(s1[i])
		org = append(org, num)
	}

	var grid [][]int
	for i := 0; i < n; i++ {
		reader.Scan()

		row := strings.Split(reader.Text(), ",")
		var newRow []int
		for _, v := range row {
			num, _ := strconv.Atoi(v)
			newRow = append(newRow, num)
		}
		grid = append(grid, newRow)
	}

	fmt.Println(check(n, org, grid))
}
```

